var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#quadgk","page":"API reference","title":"quadgk","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"The most commonly used function from the QuadGK package is the quadgk function, used to compute numerical integrals (by h-adaptive Gauss–Kronrod quadrature):","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"QuadGK.quadgk","category":"page"},{"location":"api/#QuadGK.quadgk","page":"API reference","title":"QuadGK.quadgk","text":"quadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use quadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, quadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\nquadgk(f::BatchIntegrand, a,b,c...; kws...)\n\nLike quadgk, but batches evaluation points for an in-place integrand to evaluate simultaneously. In particular, there are two differences from quadgk\n\nThe function f.f! should be of the form f!(y, x) = y .= f.(x).  That is, it writes the return values of the integand f(x) in-place into its first argument y. (The return value of f! is ignored.) See BatchIntegrand for how to define the integrand.\nf.max_batch changes how the adaptive refinement is done by batching multiple segments together. Choosing max_batch<=4*order+2 will reproduce the result of non-batched quadgk, however if max_batch=n*(4*order+2) up to 2n Kronrod rules will be evaluated together, which can produce slightly different results and sometimes require more integrand evaluations when using relative tolerances.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API reference","title":"API reference","text":"The quadgk function also has variants quadgk_count (which also returns a count of the integrand evaluations), quadgk_print (which also prints each integrand evaluation), quadgk! (which implements an in-place API for array-valued functions), as well as an alloc_segbuf function to pre-allocate internal buffers used by quadgk:","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"QuadGK.quadgk_count\nQuadGK.quadgk_print\nQuadGK.quadgk!\nQuadGK.alloc_segbuf","category":"page"},{"location":"api/#QuadGK.quadgk_count","page":"API reference","title":"QuadGK.quadgk_count","text":"quadgk_count(f, args...; kws...)\n\nIdentical to quadgk but returns a triple (I, E, count) of the estimated integral I, the estimated error bound E, and a count of the number of times the integrand f was evaluated.\n\nThe count of integrand evaluations is a useful performance metric: a large number typically indicates a badly behaved integrand (with singularities, discontinuities, sharp peaks, and/or rapid oscillations), in which case it may be possible to mathematically transform the problem in some way to improve the convergence rate.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadGK.quadgk_print","page":"API reference","title":"QuadGK.quadgk_print","text":"quadgk_print([io], f, args...; kws...)\n\nIdentical to quadgk, but prints each integrand evaluation to the stream io (defaults to stdout) in the form:\n\nf(x1) = y1\nf(x2) = y2\n...\n\nwhich is useful for pedagogy and debugging.\n\nAlso, like quadgk_count, it returns a triple (I, E, count) of the estimated integral I, the estimated error bound E, and a count of the number of times the integrand f was evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadGK.quadgk!","page":"API reference","title":"QuadGK.quadgk!","text":"quadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)\n\nLike quadgk, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from quadgk:\n\nThe function f! should be of the form f!(y, x) = y .= f(x).  That is, it writes the return value of the integand f(x) in-place into its first argument y.   (The return value of f! is ignored.)\nLike quadgk, the return value is a tuple (I,E) of the estimated integral I and the estimated error E.   However, in quadgk! the estimated integral is written in-place into the result argument, so that I === result.\n\nOtherwise, the behavior is identical to quadgk.\n\nFor integrands whose values are small arrays whose length is known at compile-time, it is usually more efficient to use quadgk and modify your integrand to return an SVector from the StaticArrays.jl package.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadGK.alloc_segbuf","page":"API reference","title":"QuadGK.alloc_segbuf","text":"function alloc_segbuf(domain_type=Float64, range_type=Float64, error_type=Float64; size=1)\n\nThis helper will allocate a segment buffer for segments to a quadgk(...) call with the given domain_type, which is the same as the type of the integration limits, range_type i.e. the range of the function being integrated and error_type, the type returned by the norm given to quadgk(...) and starting with the given size. The buffer can then be reused across multiple compatible calls to quadgk(...) to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API reference","title":"API reference","text":"For a vectorized integrand that can evaluate the integrand at multiple points simultaneously, quadgk accepts a BatchIntegrand wrapper around the user's integrand and pre-allocated input and output buffers.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"QuadGK.BatchIntegrand","category":"page"},{"location":"api/#QuadGK.BatchIntegrand","page":"API reference","title":"QuadGK.BatchIntegrand","text":"BatchIntegrand(f!, y::AbstractVector, [x::AbstractVector]; max_batch=typemax(Int))\nBatchIntegrand{Y,X}(f!; max_batch=typemax(Int)) where {Y,X}\nBatchIntegrand{Y}(f!; max_batch=typemax(Int)) where {Y}\n\nConstructor for a BatchIntegrand accepting an integrand of the form f!(y,x) = y .= f.(x) that can evaluate the integrand at multiple quadrature nodes using, for example, threads, the GPU, or distributed memory. The arguments y, and optionally x, are pre-allocated buffers of the correct element type for the domain and range of f!. Additionally, they must be resize!-able since the number of evaluation points may vary between calls to f!. Alternatively, the element types of those buffers, Y and optionally X, may be passed as type parameters to the constructor. The max_batch keyword roughly limits the number of nodes passed to the integrand, though at least 4*order+2 nodes will be used by the GK rule.\n\nInternal allocations\n\nIf x or X are not specified, quadgk internally creates a new BatchIntegrand with the user-supplied y buffer and a freshly-allocated x buffer based on the domain types. So, if you want to reuse the x buffer between calls, supply {Y,X} or pass y,x explicitly.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gauss-and-Gauss–Kronrod-rules","page":"API reference","title":"Gauss and Gauss–Kronrod rules","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"For more specialized applications, you may wish to construct your own Gauss or Gauss–Kronrod quadrature rules, as described in Gauss and Gauss–Kronrod quadrature rules.   To compute rules for int_-1^+1 f(x) dx and int_a^b f(x) dx (unweighted integrals), use:","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"QuadGK.gauss(::Type{<:AbstractFloat}, ::Integer)\nQuadGK.kronrod(::Type{<:AbstractFloat}, ::Integer)","category":"page"},{"location":"api/#QuadGK.gauss-Tuple{Type{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Integer}","page":"API reference","title":"QuadGK.gauss","text":"gauss([T,] n)\ngauss([T,] n, a, b)\n\nReturn a pair (x, w) of n quadrature points x[i] and weights w[i] to integrate functions on the interval (a b), which defaults to (-11),  i.e. sum(w .* f.(x)) approximates the integral int_a^b f(x) dx.\n\nUses the Golub–Welch method described in Trefethen & Bau, Numerical Linear Algebra, to find the n-point Gaussian quadrature rule in O(n²) operations.\n\nT is an optional parameter specifying the floating-point type, defaulting to Float64. Arbitrary precision (BigFloat) is also supported.  If T is not supplied,  but the interval (a, b) is passed, then the floating-point type is determined  from the types of a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuadGK.kronrod-Tuple{Type{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Integer}","page":"API reference","title":"QuadGK.kronrod","text":"kronrod([T,] n)\nkronrod([T,] n, a, b)\n\nCompute 2n+1 Kronrod points x[i] and weights w[i] based on the description in Laurie (1997), appendix A, for integrating on the interval (ab) (defaulting to -11).\n\nIf a and b are not passed, since the rule is symmetric, this only returns the n+1 points with x <= 0. The function Also computes the embedded n-point Gauss quadrature weights gw (again for x <= 0 if a and b are not passed), corresponding to the points x[2:2:end]. Returns (x,w,wg) in O(n²) operations.\n\nThe optional arguments a, b specify th\n\nT is an optional parameter specifying the floating-point type, defaulting to Float64. Arbitrary precision (BigFloat) is also supported.\n\nGiven these points and weights, the estimated integral I and error E can be computed for an integrand f(x) as follows:\n\nx, w, wg = kronrod(n)\nfx⁰ = f(x[end])                # f(0)\nx⁻ = x[1:end-1]                # the x < 0 Kronrod points\nfx = f.(x⁻) .+ f.((-).(x⁻))    # f(x < 0) + f(x > 0)\nI = sum(fx .* w[1:end-1]) + fx⁰ * w[end]\nif isodd(n)\n    E = abs(sum(fx[2:2:end] .* wg[1:end-1]) + fx⁰*wg[end] - I)\nelse\n    E = abs(sum(fx[2:2:end] .* wg[1:end])- I)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API reference","title":"API reference","text":"More generally, to compute rules for int_a^b W(x) f(x) dx (weighted integrals, as described in Gaussian quadrature and arbitrary weight functions), use the following methods if you know the Jacobi matrix for the orthogonal polynomials associated with your weight function:","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"QuadGK.gauss(::AbstractMatrix{<:Real}, ::Real)\nQuadGK.kronrod(::AbstractMatrix{<:Real}, ::Integer, ::Real)\nQuadGK.HollowSymTridiagonal","category":"page"},{"location":"api/#QuadGK.gauss-Tuple{AbstractMatrix{var\"#s1\"} where var\"#s1\"<:Real, Real}","page":"API reference","title":"QuadGK.gauss","text":"gauss(J::AbstractMatrix, unitintegral::Real=1, [ (a₀,b₀) => (a,b) ])\n\nConstruct the n-point Gaussian quadrature rule for If = int_a^b w(x) f(x) dx from the n times n symmetric tridiagonal Jacobi matrix J corresponding to the orthogonal polynomials for that weighted integral.  The value of unitintegral should be I1, the integral of the weight function.\n\nAn optional argument (a₀,b₀) => (a,b) allows you to specify that J was originally defined for a different interval (a_0 b_0), which you want to rescale to a given (a b).  (gauss will rescale the points and weights for you.)\n\nReturns a pair (x, w) of n quadrature points x[i] and weights w[i] to integrate functions, i.e. sum(w .* f.(x)) approximates the integral If.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuadGK.kronrod-Tuple{AbstractMatrix{var\"#s1\"} where var\"#s1\"<:Real, Integer, Real}","page":"API reference","title":"QuadGK.kronrod","text":"kronrod(J::AbstractMatrix, n::Integer, unitintegral::Real=1, [ (a₀,b₀) => (a,b) ])\n\nConstruct the 2n+1-point Gauss–Kronrod quadrature rule for If = int_a^b w(x) f(x) dx from the m times m symmetric tridiagonal Jacobi matrix J corresponding to the orthogonal polynomials for that weighted integral, where m ≥ (3n+3)÷2.  The value of unitintegral should be I1, the integral of the weight function.\n\nAn optional argument (a₀,b₀) => (a,b) allows you to specify that J was originally defined for a different interval (a_0 b_0), which you want to rescale to a given (a b).  (gauss will rescale the points and weights for you.)\n\nReturns a tuple (x, w, gw) of n quadrature points x[i] and weights w[i] to integrate functions, i.e. sum(w .* f.(x)) approximates the integral If.  gw are the weights of the embedded Gauss rule corresponding to the points x[2:2:end], which can be used for error estimation.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuadGK.HollowSymTridiagonal","page":"API reference","title":"QuadGK.HollowSymTridiagonal","text":"QuadGK.HollowSymTridiagonal(ev::AbstractVector)\n\nConstruct a \"hollow\" symmetric tridiagonal matrix, whose diagonal entries are zero and whose first sub/super-diagonal is ev.\n\nThe HollowSymTridiagonal type can be passed to gauss or kronrod for Jacobi matrices to dispatch to specialized methods that exploit the special \"hollow\" structure arising for symmetric weight functions, in order to generate symmetric quadrature rules more efficiently.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API reference","title":"API reference","text":"Most generally, if you know only the weight function W(x) and the interval (ab), you can construct Gauss and Gauss–Kronrod rules completely numerically using:","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"QuadGK.gauss(::Any, ::Integer, ::Real, ::Real)\nQuadGK.kronrod(::Any, ::Integer, ::Real, ::Real)","category":"page"},{"location":"api/#QuadGK.gauss-Tuple{Any, Integer, Real, Real}","page":"API reference","title":"QuadGK.gauss","text":"gauss(W, N, a, b; rtol=sqrt(eps), quad=quadgk)\n\nReturn a pair (x, w) of N quadrature points x[i] and weights w[i] to integrate functions on the interval (a, b) multiplied by the weight function W(x).  That is, sum(w .* f.(x)) approximates the integral ∫ W(x)f(x)dx from a to b.\n\nThis function performs 2N numerical integrals of polynomials against W(x) using the integration function quad (defaults to quadgk) with relative tolerance rtol (which defaults to half of the precision eps of the endpoints). This is followed by an O(N²) calculations. So, using a large order N is expensive.\n\nIf W has lots of singularities that make it hard to integrate numerically, you may need to decrease rtol.   You can also pass in a specialized quadrature routine via the quad keyword argument, which should accept arguments quad(f,a,b,rtol=_,atol=_) similar to quadgk.  (This is useful if your weight function has discontinuities, in which case you might want to break up the integration interval at the discontinuities.)\n\nThe precision of the calculations and return value is determined from the types of a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuadGK.kronrod-Tuple{Any, Integer, Real, Real}","page":"API reference","title":"QuadGK.kronrod","text":"kronrod(W, N, a, b; rtol=sqrt(eps), quad=quadgk)\n\nReturn a tuple (x, w, wg) of N quadrature points x[i] and weights w[i] to integrate functions on the interval (a, b) multiplied by the weight function W(x), along with the weights wg of an embedded Gauss rule corresponding to x[2:2:end], similar to the gauss(W, N, a, b) function and analogous to kronrod(N) (which only returns the x ≤ 0 points for a constant weight function).\n\nThat is, I = sum(w .* f.(x)) approximates the integral ∫ W(x)f(x)dx from a to b.  And an error estimate is abs(I - Ig), where Ig is the result Ig = sum(wg .* f.(x[2:2:end])) of the embedded Gauss rule.\n\nThis function performs ≈ 3N+3 numerical integrals of polynomials against W(x) using the integration function quad (defaults to quadgk) with relative tolerance rtol (which defaults to half of the precision eps of the endpoints). This is followed by an O(N²) calculations. So, using a large order N is expensive.\n\n\n\n\n\n","category":"method"},{"location":"gauss-kronrod/#Gauss-and-Gauss–Kronrod-quadrature-rules","page":"Quadrature rules","title":"Gauss and Gauss–Kronrod quadrature rules","text":"","category":"section"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"The foundational algorithm of the QuadGK package is a Gauss–Kronrod quadrature rule, an extension of Gaussian quadrature. In this chapter of the QuadGK manual, we briefly explain what these are, and describe how you can use QuadGK to generate your own Gauss and Gauss–Kronrod rules, including for more complicated weighted integrals.","category":"page"},{"location":"gauss-kronrod/#Quadrature-rules-and-Gaussian-quadrature","page":"Quadrature rules","title":"Quadrature rules and Gaussian quadrature","text":"","category":"section"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"A quadrature rule is simply a way to approximate an integral by a sum:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"int_a^b f(x) dx approx sum_i=1^n w_i f(x_i)","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"where the n evaluation points x_i are known as the quadrature points and the coefficients w_i are the quadrature weights.   We typically want to design quadrature rules that are as accurate as possible for as small an n as possible, for a wide range of functions f(x) (for example, for smooth functions). The underlying assumption is that evaluating the integrand f(x) is computationally expensive, so you want to do this as few times as possible for a given error tolerance.","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"There are many numerical-integration techniques for designing quadrature rules.  For example, one could simply pick the points x_i uniformly at random in (ab) and use a weight w_i = 1n to take the average — this is Monte-Carlo integration, which is simple but converges rather slowly (its error scales as sim 1sqrtn).","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"A particularly efficient class of quadrature rules is known as Gaussian quadrature, which exploits the remarkable theory of orthogonal polynomials in order to design n-point rules that exactly integrate all polynomial functions f(x) up to degree 2n-1.  More importantly, the error goes to zero extremely rapidly even for non-polynomial f(x), as long as f(x) is sufficiently smooth. (They converge exponentially rapidly for analytic functions.)  There are many variants of Gaussian quadrature, as we will discuss further below, but the specific case of computing int_-1^1 f(x) dx is known as Gauss–Legendre quadrature, and int_a^b f(x) dx over other intervals (ab) is equivalent to Gauss–Legendre under a simple change of variables (given explicitly below).","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"The QuadGK package can compute the points x_i and weights w_i of a Gauss–Legendre quadrature rule (optionally rescaled to an arbitrary interval (ab)) for you via the gauss function. For example, the n=5 point rule for integrating from a=1 to b=3 is computed by:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> a = 1; b = 3; n = 5;\n\njulia> x, w = gauss(n, a, b);\n\njulia> [x w] # show points and weights as a 2-column matrix\n5×2 Matrix{Float64}:\n 1.09382  0.236927\n 1.46153  0.478629\n 2.0      0.568889\n 2.53847  0.478629\n 2.90618  0.236927","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"We can see that there are 5 points a  x_i  b.  They are not equally spaced or equally weighted, nor do they quite reach the endpoints.  We can now approximate integrals by evaluating the integrand f(x) at these points, multiplying by the weights, and summing.  For example, f(x)=cos(x) can be integrated via:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> sum(w .* cos.(x)) # evaluate ∑ᵢ wᵢ f(xᵢ)\n-0.7003509770773674\n\njulia> sin(3) - sin(1)   # the exact integral\n-0.7003509767480293","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"Even with just n = 5 points, Gaussian quadrature can integrate such a smooth function as this to 8–9 significant digits!","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"The gauss function allows you to compute Gaussian quadrature rules to any desired precision, even supporting arbitrary-precision arithmetic types such as BigFloat.  For example, we can compute the same rule as above to about 30 digits:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> setprecision(30, base=10);\n\njulia> x, w = gauss(BigFloat, n, a, b); @show x; @show w;\nx = BigFloat[1.0938201540613360072023731217019, 1.4615306898943169089636855793001, 2.0, 2.5384693101056830910363144207015, 2.9061798459386639927976268782981]\nw = BigFloat[0.23692688505618908751426404072106, 0.47862867049936646804129151483584, 0.56888888888888888888888888888975, 0.47862867049936646804129151483584, 0.23692688505618908751426404072106]","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"This allows you to compute numerical integrals to very high accuracy if you want.  (The quadgk function also supports arbitrary-precision arithmetic types.)","category":"page"},{"location":"gauss-kronrod/#Gauss–Kronrod:-Error-estimation-and-embedded-rules","page":"Quadrature rules","title":"Gauss–Kronrod: Error estimation and embedded rules","text":"","category":"section"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"A good quadrature rule is often not enough: you also want to have an estimate of the error for a given f(x), in order to decide whether you are happy with your approximate integral or if you want to get a more accurate estimate by increasing n.","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"The most basic way to do this is to evaluate two quadrature rules, one with fewer points n  n, and use their difference as an error estimate.  (If the error is rapidly converging with n, this is usually a conservative upper bound on the error.)","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"texterror estimate = Big\nunderbracesum_i=1^n w_i f(x_i)_textfirst rule -\nunderbracesum_j=1^n w_j f(x_j)_textsecond rule\nBig","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"Naively, this requires us to evaluate our integrand f(x) an extra n times to get the error estimate from the second rule.  However, we can do better: if the points  x_j  of the second (n-point) rule are a subset of the points  x_i  of the points from the first (n-point) rule, then we only need n function evaluations for the first rule and can re-use them when evaluating the second rule. This is called an embedded (or nested) quadrature rule.","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"There are many ways of designing embedded quadrature rules.  Unfortunately, the nice Gaussian quadrature rules cannot be directly nested: the n-point Gaussian quadrature points are not a subset of the n-point Gaussian quadrature points for any 1  n  n.   Fortunately, there is a slightly modified scheme that works, called Gauss–Kronrod quadrature: if you start with an n-point Gaussian-quadrature scheme, you can extend it with n+1 additional points to obtain a quadrature scheme with n=2n+1 points that exactly integrates polynomials up to degree 3n+1. Although this is slightly worse than an n-point Gaussian quadrature scheme, it is still quite accurate, still converges very fast for smooth functions, and gives you a built-in error estimate that requires no additional function evaluations.   (In QuadGK, we refer to the size n of the embedded Gauss rule as the \"order\", although other authors use that term to refer to the degree of polynomials that are integrated exactly.)","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"The quadgk function uses Gauss–Kronrod quadrature internally, defaulting to order n=7 (i.e. n=15 points), though you can change this with the order parameter.   This gives it both an estimated integral and an estimated error.  If the error is larger than your requested tolerance, quadgk splits the integration interval into two halves and applies the same Gauss–Kronrod rule to each half, and continues to subdivide the intervals until the desired tolerance is achieved, a process called h-adaptive quadrature.  (An alternative called p-adaptive quadrature would increase the order n on the same interval.  h-adaptive quadrature is more robust if your function has localized bad behaviors like sharp peaks or discontinuities, because it will progressively add more points mostly in these \"bad\" regions.)","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"You can use the kronrod function to compute a Gauss–Kronrod rule to any desired order (and to any precision).  For example, we can extend our 5-point Gaussian-quadrature rule for int_1^3 from the previous section to an 11-point (2n+1) Gauss-Kronrod rule:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> x, w, gw = kronrod(n, a, b); [ x w ] # points and weights\n11×2 Matrix{Float64}:\n 1.01591  0.042582\n 1.09382  0.115233\n 1.24583  0.186801\n 1.46153  0.24104\n 1.72037  0.27285\n 2.0      0.282987\n 2.27963  0.27285\n 2.53847  0.24104\n 2.75417  0.186801\n 2.90618  0.115233\n 2.98409  0.042582","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"Similar to Gaussian quadrature, notice that all of the Gauss–Kronrod points a  x_i  b lie in the interior (ab) of our integration interval, and that they are unequally spaced (clustered more near the edges). The third return value, gw, gives the weights of the embedded 5-point Gaussian-quadrature rule, which corresponds to the even-indexed points x[2:2:end] of the 11-point Gauss–Kronrod rule:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> [ x[2:2:end] gw ] # embedded Gauss points and weights\n5×2 Matrix{Float64}:\n 1.09382  0.236927\n 1.46153  0.478629\n 2.0      0.568889\n 2.53847  0.478629\n 2.90618  0.236927","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"So, we can evaluate our integrand f(x) at the 11 Gauss–Kronrod points, and then re-use 5 of these values to obtain an error estimate.  For example, with f(x) = cos(x), we obtain:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> fx = cos.(x); # evaluate f(xᵢ)\n\njulia> integral = sum(w .* fx) # ∑ᵢ wᵢ f(xᵢ)\n-0.7003509767480292\n\njulia> error = abs(integral - sum(gw .* fx[2:2:end])) # |integral - ∑ⱼ wⱼ′ f(xⱼ′)|\n3.2933822335934337e-10\n\njulia> abs(integral - (sin(3) - sin(1))) # true error ≈ machine precision\n1.1102230246251565e-16","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"As noted above, the error estimate tends to actually be quite a conservative upper bound on the error, because it is effectively a measure of the error of the lower-order embedded 5-point Gauss rule rather than that of the higher-order 11-point Gauss–Kronrod rule.  For smooth functions like cos(x), an 11-point rule can have an error orders of magnitude smaller than that of the 5-point rule.  (Here, the 11-point rule's accuracy is so good that it is actually limited by floating-point roundoff error; in infinite precision the error would have been ≈ 6e-23.)","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"You may notice that both the Gauss–Kronrod and the Gaussian quadrature rules are symmetric around the center (a+b)2 of the integration interval.   In fact, we provide a lower-level function kronrod(n) that only computes roughly the first half of the points and weights for int_-1^1 (b = -a = 1), corresponding to x_i le 0.","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> x, w, gw = kronrod(5); [x w] # points xᵢ ≤ 0 and weights\n6×2 Matrix{Float64}:\n -0.984085  0.042582\n -0.90618   0.115233\n -0.754167  0.186801\n -0.538469  0.24104\n -0.27963   0.27285\n  0.0       0.282987\n\njulia> [x[2:2:end] gw] # embedded Gauss points ≤ 0 and weights\n3×2 Matrix{Float64}:\n -0.90618   0.236927\n -0.538469  0.478629\n  0.0       0.568889","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"Of course, you still have to evaluate f(x) at all 2n+1 points, but summing the results requires a bit less arithmetic and storing the rule takes less memory.  Note also that the (-11) rule can be applied to any desired interval (ab) by a change of variables","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"int_a^b f(x) dx = fracb-a2 int_-1^+1 fleft( (u+1)fracb-a2 + a  right) du  ","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"so the (-11) rule can be computed once (for a given order and precision) and re-used.  In consequence, kronrod(n) is quadgk uses internally.  The higher-level kronrod(n, a, b) function is more convenient for casual use, however.","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"As with gauss, the kronrod function works with arbitrary precision, such as BigFloat numbers.  kronrod(n, a, b) uses the precision of the endpoints (a,b) (converted to floating point), while for kronrod(n) you can explicitly pass a floating-point type T as the first argument, e.g. for 50-digit precision:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"julia> setprecision(50, base=10); x, w, gw = kronrod(BigFloat, 5); x\n6-element Vector{BigFloat}:\n -0.9840853600948424644961729346361394995805528241884714\n -0.9061798459386639927976268782993929651256519107625304\n -0.7541667265708492204408171669461158663862998043714845\n -0.5384693101056830910363144207002088049672866069055604\n -0.2796304131617831934134665227489774362421188153561727\n  0.0","category":"page"},{"location":"gauss-kronrod/#Quadrature-rules-for-weighted-integrals","page":"Quadrature rules","title":"Quadrature rules for weighted integrals","text":"","category":"section"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"More generally, one can compute quadrature rules for a weighted integral:","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"int_a^b W(x) f(x) dx approx sum_i=1^n w_i f(x_i)","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"where the effect of weight function W(x) (usually required to be  0 in (ab)) is included in the quadrature weights w_i and points x_i.   The main motivation for weighted quadrature rules is to handle poorly behaved integrands — singular, discontinuous, highly oscillatory, and so on — where the \"bad\" behavior is known and can be factored out into W(x).  By designing a quadrature rule with W(x) taken into account, one can obtain fast convergence as long as the remaining factor f(x) is smooth, regardless of how \"bad\" W(x) is.  Moreover, the rule can be re-used for many different f(x) as long as W(x) remains the same.","category":"page"},{"location":"gauss-kronrod/","page":"Quadrature rules","title":"Quadrature rules","text":"The QuadGK package can compute both Gauss and Gauss–Kronrod quadrature rules for arbitrary weight functions W(x), to arbitrary precision, as described in the section: Gaussian quadrature and arbitrary weight functions.","category":"page"},{"location":"quadgk-examples/#quadgk-examples","page":"Examples","title":"quadgk examples","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The following are several examples illustrating the usage of the main quadgk numerical-integration function of QuadGK, focusing on more complicated circumstances than the smooth scalar integral of the Quick start section.","category":"page"},{"location":"quadgk-examples/#Improper-integrals:-Infinite-limits","page":"Examples","title":"Improper integrals: Infinite limits","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"quadgk supports \"improper\" integrals over infinite and semi-infinite intervals, simply by passing ±Inf for the endpoints.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, int_0^infty e^-x dx = 1 is computed by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> exp(-x), 0, Inf)\n(1.0, 4.507383379289404e-11)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which give gives the correct answer (1) exactly in this case.  Note that the error estimate ≈ 4.5e-11 is pessimistic, as is often the case.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The Gaussian integral int_-infty^+infty e^-x^2 dx = sqrtpi = 1772453850905516027298167483341ldots is computed by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> exp(-x^2), -Inf, Inf)\n(1.7724538509055137, 6.4296367126505234e-9)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which is the correct answer to nearly machine precision, despite the pessimistic error estimate ≈ 6.4e-9.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Internally, quadgk handles infinite limits by the changes of variables","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"int_a^infty f(x)dx = int_0^1 fleft(a + fract1-tright) frac1(1-t)^2 dt","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"and","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"int_-infty^infty f(x)dx = int_-1^1 fleft(fract1-t^2right) frac1+t^2(1-t^2)^2 dt","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"respectively.   Although the transformed integrands are singular at the endpoints t = 1 and t = pm 1, respectively, because the singularities are integrable and quadgk never evaluates the integrand exactly at the endpoints, it is able to perform the numerical integration successfully.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Important tip: This change-of-variables trick works best if your function decays with x over a lengthscale of order sim 1. If your decay length is much larger or shorter than that, it will perform poorly.  For example, with f(x) = e^-x10^6 the decay is over a lengthscale sim 10^6 and quadgk requires many more evaluations (705) than for e^-x (135, as measured by quadgk_count, described below):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> exp(-x), 0, Inf)\n(1.0, 4.507382674563286e-11, 135)\n\njulia> quadgk_count(x -> exp(-x/1e6), 0, Inf)\n(1.000000000001407e6, 0.0014578728207218505, 705)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"If your function decays over a lengthscale sim L, it is a good idea to compute improper integrals using a change of variables int_a^b f(x)dx = int_aL^bL f(uL) L  du, for example:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> L = 1e6 # decay lengthscale\n1.0e6\n\njulia> f(x) = exp(-x/L)\nf (generic function with 1 method)\n\njulia> quadgk_count(u -> f(u*L) * L, 0, Inf) # rescaled integration over u = x/L\n(1.0e6, 4.507388807828416e-5, 135)","category":"page"},{"location":"quadgk-examples/#Counting-and-printing-integrand-evaluations","page":"Examples","title":"Counting and printing integrand evaluations","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Often, it is a good idea to count the number of times the integrand is evaluated, in order to have a sense of how efficiently quadgk is performing the integral; this is especially useful with badly behaved integrand (e.g. with singularities, discontinuities, sharp spikes, and/or rapid oscillations) to see whether some transformation of the problem might be helpful (see below).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"This is easy enough by simply incrementing a global counter in your integrand function and printing progress as desired.    But it is such a common desire in pedagogy and debugging that we provide convenience functions quadgk_count and quadgk_print to automate this task.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, in our int_0^infty e^-x dx example from above, we could do:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> exp(-x), 0, Inf)\n(1.0, 4.507383379289404e-11, 135)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"to return the number of function evaluations (135) along with the integral (1.0) and error estimate (≈ 4.5e-11).   A relatively large number of function evaluations are required, even though the function e^-x is very smooth, because the infinite endpoint implicitly introduces a singularity (via the change of variables discussed above).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"We can also print the evaluation points, setting a lower requested relative accuracy of rtol=1e-2 so that we don't get so much output, by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_print(x -> exp(-x), 0, Inf, rtol=1e-2)\nf(1.0) = 0.36787944117144233\nf(0.655923922306948) = 0.5189623601162878\nf(1.52456705113438) = 0.21771529605384055\nf(0.026110451522445993) = 0.9742274787577301\nf(38.29883980138536) = 2.3282264081806294e-17\nf(0.00429064542600238) = 0.9957185462423211\nf(233.06516868994527) = 6.04064500678147e-102\nf(0.14841469193194298) = 0.8620735458624529\nf(6.737877409458626) = 0.0011851600983136456\nf(0.07246402202084404) = 0.9300992091482783\nf(13.799951646519888) = 1.015680581505947e-6\nf(0.42263178703605514) = 0.6553198859704107\nf(2.3661258586654506) = 0.09384358625528809\nf(0.26096469051417465) = 0.7703081183184751\nf(3.831936029467112) = 0.021667625834125973\n(0.9999887201849575, 0.0009180738585039538, 15)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"to see that (for a relatively low requested relative accuracy of rtol=1e-2) it evaluates the integrand only 15 times at points from x approx 000429 to x approx 2331, and still managed to get about 5 significant digits correct.  (Note that quadgk_print again returns a 3-element tuple, like quadgk_count, where the third element is the number of integrand evaluations.)","category":"page"},{"location":"quadgk-examples/#Integrands-with-singularities-and-discontinuities","page":"Examples","title":"Integrands with singularities and discontinuities","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The integral int_0^1 x^-12 dx = left 2 sqrtx right_0^1 = 2 is perfectly finite even though the integrand 1sqrtx blows up at x=0.  This is an example of an integrable singularity, and quadgk can compute this integral:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> 1/sqrt(x), 0, 1)\n(1.9999999845983916, 2.3762511924588765e-8, 1305)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Notice the large number (1305) of integrand evaluations returned by quadgk_count: this is an indication of how much more work it is to evaluate an integral with a singularity or any other form of non-smoothness. At its heart, the Gauss–Kronrod algorithm employed by quadgk works by interpolating the integrand with polynomials over segments of the domain, and polynomials are bad at representing non-analytic functions like 1sqrtx.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The good news is that quadgk never evaluates functions exactly at the endpoints, so it is okay if your function blows up or errors at those points.   However, this means that if you function blows up in the interior of the integration domain, you should add an extra \"endpoint\" at that point to make sure we never evaluate it. (Also, quadgk can often converge more quickly if you tell it where your singularities are via the endpoints.)  For example, suppose we are integrating int_0^2 x-1^-12 dx = 4, which has an (integrable) singularity at x=1. If we don't tell quadgk about the singularity, it gets \"unlucky\" and evaluates the integrand exactly at x=1, which ends up throwing an error:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> 1/sqrt(abs(x-1)), 0, 2)\nERROR: DomainError with 1.0:\nintegrand produced NaN in the interval (0, 2)\n...","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Instead, if we tell it to subdivide the integral at x=1, we get the correct answer(≈ 4):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> 1/sqrt(abs(x-1)), 0, 1, 2)\n(3.9999999643041515, 5.8392038954259235e-8, 2580)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"In general, the syntax quadgk(f, a, b, c, ...) denotes the integral int_a^b f(x)dx + int_b^c f(x)dx  + cdots, and quadgk never evaluates the integrand f(x) exactly at the endpoints a b c ldots.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As another example, consider an integral int_0^3 H(x-1) = 2 of the discontinuous Heaviside step function H(x), which =1 when x  0 and =0 when x le 0:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> x > 1, 0, 3)\n(2.0000000043200235, 1.7916158219741817e-8, 705)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Even though H(x-1) is nearly constant, quadgk struggles to integrate it (705 function evaluations to get about 8 digits), thanks to the discontinuity at x=1. (Note that true and false in Julia are equal to numeric 0 and 1, which is why we could implement H(x-1) as simply x > 1.) On the other hand, if we tell it the location of the discontinuity:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> x > 1, 0, 1, 3)\n(2.0, 0.0, 30)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"then it gives the exact answer in only 30 evaluations.  The reason it takes 30 evaluations is because quadgk defaults to 7th-order Gauss–Kronrod integration rule, which uses 15 points to interpolate with a high-degree polynomial.  Once we subdivide the integral, we could actually get away with a lower-order rule by setting the order parameter, e.g.:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> x > 1, 0, 1, 3, order=1)\n(2.0, 0.0, 6)","category":"page"},{"location":"quadgk-examples/#Complex-and-vector-valued-integrands","page":"Examples","title":"Complex and vector-valued integrands","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The integrand f(x) can return not just real numbers, but also complex numbers, vectors, matrices, or any Julia type supporting ±, multiplication by scalars, and norm (i.e. implementing any Banach space).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, we can integrate 1sqrtx from x=-1 to x=1, where we tell the sqrt function to return a complex result for negative arguments:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> 1/sqrt(complex(x)), -1, 0, 1)\n(1.9999999891094182 - 1.9999999845983916im, 4.056765398346683e-8)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which correctly gives approx 2 - 2i.  Note that we explicitly put an endpoint at x=0 to tell quadgk about the singularity at that point, as described above.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Or let's integrate the vector-valued function f(x) = 1 x x^2 x^3 for x in (01):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> [1,x,x^2,x^3], 0, 1)\n([1.0, 0.5, 0.3333333333333333, 0.25], 6.206335383118183e-17)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which correctly returns approx 1 frac12 frac13 frac14.  Note that the error estimate in this case is an approximate bound on the norm of the error, as computed by the LinearAlgebra.norm function in Julia.  It defaults to the Euclidean (L2) norm, but you can change this with the norm argument:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> [1,x,x^2,x^3], 0, 1, norm=v->maximum(abs, v))\n([1.0, 0.5, 0.3333333333333333, 0.25], 5.551115123125783e-17)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"e.g. to use the maximum norm or some other norm (e.g. a weighted norm if the different components have different units or have unequal error tolerances).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For integrands whose values are small arrays whose length is known at compile time, it is usually most efficient to modify your integrand to return an SVector from the StaticArrays.jl package.  For the example above:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> using StaticArrays\n\njulia> integral, error = quadgk(x -> @SVector[1,x,x^2,x^3], 0, 1)\n([1.0, 0.5, 0.3333333333333333, 0.25], 6.206335383118183e-17)\n\njulia> typeof(integral)\nSVector{4, Float64} (alias for SArray{Tuple{4}, Float64, 1, 4})","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Note that the return value also gives the integral as an SVector (a statically sized array).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The QuadGK package did not need any code specific to StaticArrays, and was written long before that package even existed.  The fact that unrelated packages like this can be composed is part of the beauty of multiple dispatch and duck typing for generic programming.","category":"page"},{"location":"quadgk-examples/#Batched-integrand-evaluation","page":"Examples","title":"Batched integrand evaluation","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"User-side parallelization of integrand evaluations is also possible by providing an in-place function of the form f!(y,x) = y .= f.(x), which evaluates the integrand at multiple points simultaneously. To use this API, quadgk dispatches on a BatchIntegrand type containing f! and buffers for y and x. These buffers may be pre-allocated and reused for multiple BatchIntegrands with the same domain and range types.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, we can perform multi-threaded integration of a highly oscillatory function that needs to be refined globally:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> f(x) = sin(100x)\nf (generic function with 1 method)\n\njulia> function f!(y, x)\n           n = Threads.nthreads()\n           Threads.@threads for i in 1:n\n                y[i:n:end] .= f.(@view(x[i:n:end]))\n           end\n       end\nf! (generic function with 1 method)\n\njulia> quadgk(BatchIntegrand{Float64}(f!), 0, 1)\n(0.0013768112771231598, 8.493080824940099e-12)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Batching also changes how the adaptive refinement is done, which typically leads to slightly different results and sometimes more integrand evaluations. You can limit the maximum batch size by setting the max_batch parameter of the BatchIntegrand, which can be useful in order to set an upper bound on the size of the buffers allocated by quadgk.","category":"page"},{"location":"quadgk-examples/#Arbitrary-precision-integrals","page":"Examples","title":"Arbitrary-precision integrals","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"quadgk also supports arbitrary-precision arithmetic using Julia's BigFloat type to compute integrals to arbitrary accuracy (albeit at increased computational cost).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, we can compute the error function fracsqrtpi2 texterf(1) = int_0^1 e^-x^2 dx to 50 digits by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> setprecision(60, base=10) # use 60-digit arithmetic\n60\n\njulia> quadgk_count(x -> exp(-x^2), big\"0.0\", big\"1.0\", rtol=1e-50)\n(0.74682413281242702539946743613185300535449968681260632902766195, 6.8956257635323481758755998484087241330474674891762053644928492e-51, 15345)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The correct answer is ≈ 0.746824132812427025399467436131853005354499686812606329027654498958605…, and we are matching that to nearly the full precision (≈ 60 digits).  (As usual, the error estimate of quadgk is very conservative for smooth functions.)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Unfortunately, it took 15345 function evaluations to obtain such an accurate answer.  Since this a smooth integrand, for high-accuracy calculations it is often advisable to increase the \"order\" of the quadrature algorithm (which is related to the degree of polynomials used for interpolation).  The default is order=7, but let's try tripling it to order=21:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> exp(-x^2), big\"0.0\", big\"1.0\", rtol=1e-50, order=21)\n(0.74682413281242702539946743613185300535449968681260632902765324, 2.1873898701681913100611385149037136705674736373054902472850425e-58, 129)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"It got the same accuracy (≈ 60 digits) with only 129 integrand evaluations!","category":"page"},{"location":"quadgk-examples/#Contour-integration","page":"Examples","title":"Contour integration","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"You can specify a sequence of points in the complex plane to perform a contour integrals with quadgk along a piecewise-linear contour.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, consider the function f(z) = cos(z)z.  By the residue theorem of complex analysis, if we integrate counter-clockwise in a \"loop\" around the pole at z=0, we should get exactly 2pi i cos(0) = 2pi i.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"One way to do this integral is to parameterize a contour, say a circle z=1 parameterized by z= e^iphi (= cis(ϕ) in Julia), which gives dz = i z dphi, to obtain an ordinary integral int_0^2pi fraccos(e^iphi)e^iphi ie^iphi dphi over the real parameter phi in (02pi):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(ϕ -> cos(cis(ϕ)) * im, 0, 2π)\n(0.0 + 6.283185307179586im, 1.8649646913725044e-8)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which indeed gives us approx 2pi i (to machine precision).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As an alternative, however, you can directly supply a sequence of complex \"endpoints\" to quadgk and it will perform the contour integral along a sequence of line segments connecting these points.  For example, instead of integrating around a circular contour, we can integrate around the diamond (rotated square) connecting the corners pm 1 and pm i:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(z -> cos(z)/z, 1, im, -1, -im, 1)\n(0.0 + 6.283185307179587im, 5.369976662961913e-9)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which again gives approx 2pi i (to machine precision).  Note that it is critically important to have a closed contour (a loop): the final endpoint must be the same as the starting point (z=1).","category":"page"},{"location":"quadgk-examples/#Cauchy-principal-values","page":"Examples","title":"Cauchy principal values","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Integrands f(x) = g(x)x that diverge sim 1x cannot be integrated through x=0 in the usual way (the singularity is not integrable). However, if you integrate around x=0, for both signs of x, then you can define a kind of integral that is the \"difference\" of the divergence on the two sides.  This definition is called a Cauchy principal value, and is usually presented as a limit:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"textpvint_a^b fracg(x)x dx =\nlim_varepsilonto 0^+ left\n    int_a^-varepsilon fracg(x)x dx + int_+varepsilon^b fracg(x)x dx\nright  ","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"That is, you subtract a \"ball\" of radius varepsilon from the integration domain a  0  b to eliminate the singularity at x=0, and take the limit of the resulting integral as the varepsilon goes to zero.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"In principle, you might imagine taking this limit numerically by extrapolation of numerical integrals for a sequence of varepsilon  0 values, perhaps using Richardson extrapolation via the Richardson.jl package.  However, it is mathematically equivalent and much more efficient to use a simple singularity-subtraction procedure:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"fracg(x)x  =\nfracg(x)-g(0)x + fracg(0)x","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"where the first term is not singular if g(x) is differentiable at x=0, and the latter term can be integrated analytically, giving:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"textpvint_a^b fracg(x)x dx = int_a^b fracg(x)-g(0)x dx +\ng(0) logba","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Since the remaining integral has no singularity, we can do it numerically directly.  There are two tricks to help us a bit further:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As in Integrands with singularities and discontinuities above, we'll want to put an extra endpoint at x=0 to make sure quadgk doesn't evaluate the integrand exactly at that point (which would give NaN from 00).\nWe should be careful with the integration tolerances, to make sure that any relative tolerance rtol is applied with respect to the whole principal part and not just to the g(x)-g(0) integral.  An easy way to do this is to add g(0) fraclogbab-a to the integrand, so that we no longer compute the two pieces separately.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Putting it all together, here is a function cauchy_quadgk(g, a, b) that computes our Cauchy principal part textpvint_a^b g(x)x:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"function cauchy_quadgk(g, a, b; kws...)\n    a < 0 < b || throw(ArgumentError(\"domain must include 0\"))\n    g₀ = g(0)\n    g₀int = b == -a ? zero(g₀) : g₀ * log(abs(b/a)) / (b - a)\n    return quadgk_count(x -> (g(x)-g₀)/x + g₀int, a, 0, b; kws...)\nend","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, Mathematica tells us that","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"textpv int_-1^2 fraccos(x^2-1)x dx approx 0212451309942989788929352736695ldots ","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"and we can reproduce this with cauchy_quadgk:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> cauchy_quadgk(x -> cos(x^2-1), -1, 2)\n(0.21245130994298977, 1.8366794196644776e-11, 60)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which is correct to about 16 digits.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"This approach and other approaches to computing Cauchy principal values are discussed in Keller and Wróbel (2016). This kind of \"singularity subtraction\" is a powerful approach to efficient computation of integrals with singularities or near singularities. A huge variety of related techniques have been developed for boundary element methods, where a vast number of singular integrals must be computed and efficiency is at a premium.  See, for example, Reid et al. (2014) and references therein.","category":"page"},{"location":"quadgk-examples/#Nearly-singular-integrands","page":"Examples","title":"Nearly singular integrands","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Even if the integrand is only nearly singular, so that there is a sharp but finite peak within the integration domain, it can greatly increase the efficiency of numerical integration if you can separate the sharp peak analytically.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, suppose that you are integrating:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"I = int_a^b fracg(x)x - ialpha dx","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"for a small 0  alpha ll 1.  For alpha to 0^+, it approaches ipi g(0) plus a Cauchy principal part (the latter being zero if a = -b and g(x)=g(-x)), but for small alpha  0 you have to numerically integrate (for a general function g(x)) a function with a sharp spike at x=0, which will require a large number of quadrature points.  But you can subtract out the singularity analytically:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"I = int_a^b left fracg(x)-g(0)x - ialpha + fracg(0)x - ialpha right dx \n= int_a^b fracg(x)-g(0)x - ialphadx + underbraceg(0) leftfrac12log(x^2 + alpha^2) + itan^-1(xalpha) right_a^b_I_0","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"and then you only need to numerically integrate I - I_0, which has the spike subtracted.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As for Cauchy principal values above, we want to include a I_0  (b-a) term directly in the integrand so that the error tolerances are computed correctly, and include x=0 as an explicit endpoint to let quadgk know that the integral is badly behaved there.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"In code:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"using QuadGK\n\nfunction int_slow(g, α, a, b; kws...)\n    if a < 0 < b\n        # put an explicit endpoint at x=0 since we know it is badly behaved there\n        return quadgk_count(x -> g(x) / (x - im*α), a, 0, b; kws...)\n    else\n        return quadgk_count(x -> g(x) / (x - im*α), a, b; kws...)\n    end\nend\n\nfunction int_fast(g, α, a, b; kws...)\n    g₀ = g(0)\n    denom_int(x) = log(x^2 + α^2)/2 + im * atan(x/α)\n    I₀ = g₀ * (denom_int(b) - denom_int(a))\n    if a < 0 < b\n        # put an explicit endpoint at x=0 since we know it is badly behaved there\n        (I,E,c) = quadgk_count(x -> I₀/(b-a) + (g(x) - g₀) / (x - im*α), a, 0, b; kws...)\n    else\n        (I,E,c) = quadgk_count(x -> I₀/(b-a) + (g(x) - g₀) / (x - im*α), a, b; kws...)\n    end\n    return (I,E,c+1) # add 1 for g(0) evaluation\nend","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"This gives:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> int_slow(cos, 1e-6, -1, 1)\n(1.1102230246251565e-16 + 3.1415896808206125im, 1.4895091715264936e-9, 1230)\n\njulia> int_fast(cos, 1e-6, -1, 1)\n(3.3306690738754696e-16 + 3.1415896808190418im, 1.8459683038047577e-12, 31)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which agree to about 13 digits, but the slow brute-force method requires 1230 function evaluations while the fast singularity-subtracted method requires only 31 function evaluations.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As an added bonus, int_fast works even for α = 0, where it gives you ipi g(0) (for 0 in (ab)) plus the Cauchy principal part as above.","category":"page"},{"location":"weighted-gauss/#Gaussian-quadrature-and-arbitrary-weight-functions","page":"Weighted quadrature","title":"Gaussian quadrature and arbitrary weight functions","text":"","category":"section"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"The manual chapter on Gauss and Gauss–Kronrod quadrature rules explains the fundamentals of numerical integration (\"quadrature\") to approximate int_a^b f(x) dx by a weighted sum of f(x_i) values at quadrature points x_i.  Make sure you understand that chapter before reading this one!","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"More generally, one can compute quadrature rules for a weighted integral:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"int_a^b W(x) f(x) dx approx sum_i=1^n w_i f(x_i)  ","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"where the effect of weight function W(x) (usually required to be  0 in (ab)) is included in the quadrature weights w_i and points x_i.  The main motivation for weighted quadrature rules is to handle poorly behaved integrands — singular, discontinuous, highly oscillatory, and so on — where the \"bad\" behavior is known and can be factored out into W(x).  By designing a quadrature rule with W(x) taken into account, one can obtain fast convergence as long as the remaining factor f(x) is smooth, regardless of how \"bad\" W(x) is.  Moreover, the rule can be re-used for many different f(x) as long as W(x) remains the same.","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Gaussian quadrature is ideally suited to designing weighted quadrature rules, and QuadGK includes functions to construct the points x_i and weights w_i for nearly any desired weight function W(x) ge 0, in principle, to any desired precision.   The case of Gauss–Kronrod rules (if you want an error estimate) is a bit trickier: it turns out that Gauss–Kronrod rules may not exist for arbitrary weight functions [see the review in Notaris (2016)], but if a (real-valued) rule does exist then QuadGK can compute it for you (to arbitrary precision) using an algorithm by Laurie (1997).  You can specify the weight function W(x) and the interval (ab) in one of two ways:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Via the Jacobi matrix of the orthogonal polynomials associated with this weighted integral.  That may sound complicated, but it turns out that these are tabulated for many important weighted integrals.  For example, all of the weighted integrals in the FastGaussQuadrature.jl package are based on well-known recurrences that you can look up easily.\nBy explicitly providing the weight function W(x), in which case QuadGK can perform a sequence of numerical integrals of W(x) against polynomials (using quadgk) to numerically construct the Jacobi matrix and hence the Gauss or Gauss–Kronrod quadrature rule.  (This can be computationally expensive, especially to attain high accuracy, but it can still be worthwhile if you re-use the quadrature rule for many different f(x) and/or f(x) is extremely computationally expensive.)","category":"page"},{"location":"weighted-gauss/#Weight-functions-and-Jacobi-matrices","page":"Weighted quadrature","title":"Weight functions and Jacobi matrices","text":"","category":"section"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"For any weighted integral If = int_a^b W(x) f(x) with non-negative W(x), there is an associated set of orthogonal polynomials p_k(x) of degrees k = 01ldots, such that Ip_j p_k = 0 for j ne k.   Amazingly, the n-point Gaussian quadrature points x_i are simply the roots of p_n(x), and in general there is a deep relationship between quadrature and the theory of orthogonal polynomials.   A key part of this theory ends up being the Jacobi matrix describing the three-term recurrence of these polynomials for a given weighted integral.","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"It turns out that orthogonal polynomials always obey a three-term recurrence relationship","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"p_k+1(x) = (a_k x + b_k)p_k(x) - c_k q_k-1(x)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"for some coefficients a_k  0, b_k, and c_k0 that depend on the integral I. By a rescaling p_k = q_k prod_jk a_k, this simplifies to:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"q_k+1(x) = (x - alpha_k)q_k(x) - beta_k q_k-1(x)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"for  coefficients alpha_k = -b_ka_k and beta_k = c_ka_k a_k-1  0.  (Once you know these coefficients, in fact, you can obtain all of the orthogonal polynomials by q_-1=0 q_0=1 q_1=(x-alpha_0) q_2=(x-alpha_1)(x-alpha_0) - beta_1ldots.) The coefficients are also associated with an infinite real-symmetric tridiagonal \"Jacobi\" matrix:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"J = beginpmatrix\nalpha_0  sqrtbeta_1    \nsqrtbeta_1  alpha_1  sqrtbeta_2   \n sqrtbeta_2  alpha_2  sqrtbeta_3  \n  ddots  ddots  ddots\nendpmatrix ","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Let J_n be the n times n upper-left corner of J.   Astonishingly, the quadrature points x_i turn out to be exactly the eigenvalues of J, and the quadrature weights w_i are the first components² of the corresponding normalized eigenvectors, scaled by I1 (Golub & Welch, 1968)!","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Given the n times n matrix J_n (represented by a LinearAlgebra.SymTridiagonal object, which only stores the alpha_k and sqrtbeta_k coefficients) and the integral unitintegral = I1, you can construct the points x_i and weights w_i of the n-point Gaussian quadrature rule in QuadGK via x, w = gauss(Jₙ, unitintegral).  To construct the (2n+1)-point Kronrod rule, then you need the m times m matrix J_m where m ≥ div(3n+3,2) (m ge lfloor (3n+3)2 rfloor), and then obtain the points x and weights w (along with embedded Gauss weights gw) via x, w, gw = kronrod(Jₘ, n, unitintegral).  Much of the time, you can simply look up formulas for the recurrence relations for weight functions of common interest.   Hopefully, this will be clearer with some examples below.","category":"page"},{"location":"weighted-gauss/#Gauss–Legendre-quadrature-via-the-Jacobi-matrix","page":"Weighted quadrature","title":"Gauss–Legendre quadrature via the Jacobi matrix","text":"","category":"section"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"The common case of integrals If = int_-1^+1 f(x) dx, corresponding to the weight function W(x) = 1 over the interval (-11), leads to the Legendre polynomials:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"p_0(x) = 1  p_1(x) = x  p_2(x) = (3x^2 - 1)2  ldots","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"which satisfy the recurrence (found on Wikipedia and in many other sources):","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"(k+1)p_k+1(x) = (2k+1)x p_k(x) - k p_k-1(x)  ","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"In the notation given above, that corresponds to coefficients a_k = (2k+1)(k+1), b_k = 0, and c_k = k(k+1), or equivalently alpha_k = 0 and beta_k = c_ka_k a_k-1 = k^2  (4k^2 - 1), giving a Jacobi matrix:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"J = beginpmatrix\n0  sqrt13    \nsqrt13  0  sqrt415   \n sqrt415  0  sqrt935  \n  ddots  ddots  ddots\nendpmatrix ","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"which can be constructed in Julia by","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> using LinearAlgebra # for SymTridiagonal\n\njulia> J(n) = SymTridiagonal(zeros(n), [sqrt(k^2/(4k^2-1)) for k=1:n-1]) # the n×n matrix Jₙ\nJ (generic function with 1 method)\n\njulia> J(5)\n5×5 SymTridiagonal{Float64, Vector{Float64}}:\n 0.0      0.57735    ⋅         ⋅         ⋅\n 0.57735  0.0       0.516398   ⋅         ⋅\n  ⋅       0.516398  0.0       0.507093   ⋅\n  ⋅        ⋅        0.507093  0.0       0.503953\n  ⋅        ⋅         ⋅        0.503953  0.0","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"The unit integral is simply I1 = int_-1^+1 dx = 2, so we can construct our n-point Gauss rule with, for example:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> x, w = gauss(J(5), 2); [x w]\n5×2 Matrix{Float64}:\n -0.90618   0.236927\n -0.538469  0.478629\n  0.0       0.568889\n  0.538469  0.478629\n  0.90618   0.236927","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"This is, of course, the same as the \"standard\" Gaussian quadrature rule, returned by gauss(n):","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> x, w = gauss(5); [x w]\n5×2 Matrix{Float64}:\n -0.90618   0.236927\n -0.538469  0.478629\n  0.0       0.568889\n  0.538469  0.478629\n  0.90618   0.236927","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Similarly, the 5-point Gauss–Kronrod rule can be constructed from the 9times 9 Jacobi matrix (9 = (3n+3)2):","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> x, w, gw = kronrod(J(9), 5, 2); [x w]\n11×2 Matrix{Float64}:\n -0.984085  0.042582\n -0.90618   0.115233\n -0.754167  0.186801\n -0.538469  0.24104\n -0.27963   0.27285\n  0.0       0.282987\n  0.27963   0.27285\n  0.538469  0.24104\n  0.754167  0.186801\n  0.90618   0.115233\n  0.984085  0.042582","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"which is the same as the \"standard\" Gauss–Kronrod rule returned by kronrod(n) (returning only the x_i le 0 points) or kronrod(n, -1, +1) (returning all the points):","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> x, w, gw = kronrod(5); [x w]\n6×2 Matrix{Float64}:\n -0.984085  0.042582\n -0.90618   0.115233\n -0.754167  0.186801\n -0.538469  0.24104\n -0.27963   0.27285\n  0.0       0.282987","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Notice that, in this case, our Jacobi matrix had zero diagonal entries alpha_k = 0.  It turns out that this always happens when the integration is centered around zero (a=-b) and the weight function W(x) that is symmetric (W(x)=W(-x)).   This is called a \"hollow\" tridiagonal matrix, and its eigenvalues always come in pm x_j pairs: the quadrature rule is has symmetric points and weights.   In this case QuadGK can do its computations a bit more efficiently, and only compute the non-redundant x_i le 0 half of of the quadrature rule, if you represent J_n with a special type QuadGK.HollowSymTridiagonal whose constructor only requires you to supply the off-diagonal elements sqrtbeta_k:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> JholloW(n) = QuadGK.HollowSymTridiagonal([sqrt(k^2/(4k^2-1)) for k=1:n-1])\nJhollow (generic function with 1 method)\n\njulia> JholloW(5)\n5×5 QuadGK.HollowSymTridiagonal{Float64, Vector{Float64}}:\n  ⋅       0.57735    ⋅         ⋅         ⋅\n 0.57735   ⋅        0.516398   ⋅         ⋅\n  ⋅       0.516398   ⋅        0.507093   ⋅\n  ⋅        ⋅        0.507093   ⋅        0.503953\n  ⋅        ⋅         ⋅        0.503953   ⋅\n\njulia> x, w = gauss(JholloW(5), 2); [x w]\n5×2 Matrix{Float64}:\n -0.90618   0.236927\n -0.538469  0.478629\n  0.0       0.568889\n  0.538469  0.478629\n  0.90618   0.236927\n\njulia> x, w, gw = kronrod(JholloW(9), 5, 2); [x w] # only returns xᵢ ≤ 0 points:\n6×2 Matrix{Float64}:\n -0.984085  0.042582\n -0.90618   0.115233\n -0.754167  0.186801\n -0.538469  0.24104\n -0.27963   0.27285\n  0.0       0.282987","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"(The gauss function returns all the points, albeit computed more efficiently, while the kronrod function returns only the x_i le 0 points for a HollowSymTridiagonal Jacobi matrix.)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"If you have the Jacobi matrix for one interval, but want QuadGK to rescale the quadrature points and weights to some other interval (rather than doing the change of variables yourself), you can use the method gauss(J, unitintegral,  (a,b) => (newa, newb)), where (newa,newb) is the new interval and unitintegral is the integral of f(x)=1 over the new interval, and similarly for kronrod.  For example, to rescale the Legendre W(x)=1 rule from (-1+1) to the interval (47), with unit integral 7-4 = 3, we could do:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> x, w = gauss(JholloW(5), 3, (-1,1) => (4,7)); [x w]\n5×2 Matrix{Float64}:\n 4.14073  0.35539\n 4.6923   0.717943\n 5.5      0.853333\n 6.3077   0.717943\n 6.85927  0.35539\n\njulia> x, w = kronrod(JholloW(9), 5, 3, (-1,1) => (4,7)); [x w]\n11×2 Matrix{Float64}:\n 4.02387  0.0638731\n 4.14073  0.17285\n 4.36875  0.280201\n 4.6923   0.361561\n 5.08055  0.409275\n 5.5      0.424481\n 5.91945  0.409275\n 6.3077   0.361561\n 6.63125  0.280201\n 6.85927  0.17285\n 6.97613  0.0638731","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"(When the result is rescaled to a new interval, both functions return all of the points, but they are still computed more efficiently for a HollowSymTridiagonal Jacobi matrix.)","category":"page"},{"location":"weighted-gauss/#Gauss–Jacobi-quadrature-via-the-Jacobi-matrix","page":"Weighted quadrature","title":"Gauss–Jacobi quadrature via the Jacobi matrix","text":"","category":"section"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"A typical application of weighted quadrature rules is to accelerate convergence for integrands that have power-law singularities at one or both of the endpoints.  Without loss of generality, we can rescale the interval to (-1+1), in which case such integrals are of the form:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"If = int_-1^+1 underbrace(1-x)^alpha (1+x)^beta_W(x) f(x) dx  ","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"where alpha  -1 and beta  -1 are the power laws at the two endpoints, which we have factored out into a weight function W(x) = (1+x)^alpha (1-x)^beta multiplied by some (hopefully smooth) function f(x).  For example, alpha = 05 means that there is a square-root singularity at x=+1 (where the integrand is finite, but its slope blows up).  Or if beta = -01 then the integrand blows up at x=-1 but the integral is still finite (1x^01 is an \"integrable singularity\").   This weight function is quite well known, in fact: it yields Gauss–Jacobi quadrature, with the corresponding orthogonal polynomials being the Jacobi polynomials.","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Again, we can simply look up the 3-term recurrence for the Jacobi polynomials p_n corresponding to this weight function:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"2k (k + alpha + beta) (2k + alpha + beta - 2) p_k(x) = (2k+alpha + beta-1) Big (2k+alpha + beta)(2k+alpha+beta-2) x +  alpha^2 - beta^2 Big p_k-1(x) - 2 (k+alpha - 1) (k + beta-1) (2k+alpha + beta) p_k-2(x)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"giving alpha_k and beta_k by the earlier formulas, after a bit of algebra. We also will need the unit integral","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"I1 = int_-1^+1 (1+x)^alpha (1-x)^beta dx  = frac2^alpha + beta + 1alpha + beta + 1 fracGamma(alpha+1)Gamma(beta+1)Gamma(alpha+beta+1)  ","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"where Gamma is the Gamma function, computed in Julia by SpecialFunctions.jl.  This is all rather tedious, but fortunately exactly these expressions have already been worked out for us by the FastGaussQuadrature.jl package, in undocumented functions FastGaussQuadrature.jacobi_jacobimatrix(n, α, β) (which computes the Jacobi matrix J_n) and FastGaussQuadrature.jacobimoment(α, β) (which computes I1).","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"We can use these to immediately compute the Gauss and Gauss–Kronrod points and weights for the Jacobi weight function, say for alpha = 05, beta = -01, and n=5:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> using FastGaussQuadrature, QuadGK\n\njulia> α, β, n = 0.5, -0.1, 5;\n\njulia> Jₙ = FastGaussQuadrature.jacobi_jacobimatrix(n, α, β)\n5×5 LinearAlgebra.SymTridiagonal{Float64, Vector{Float64}}:\n -0.25       0.525105     ⋅            ⋅            ⋅\n  0.525105  -0.0227273   0.506534      ⋅            ⋅\n   ⋅         0.506534   -0.00852273   0.503003      ⋅\n   ⋅          ⋅          0.503003    -0.00446429   0.501725\n   ⋅          ⋅           ⋅           0.501725    -0.00274725\n\njulia> I₁ = FastGaussQuadrature.jacobimoment(α, β)\n2.012023098289125\n\njulia> x, w = gauss(Jₙ, I₁); [x w]\n5×2 Matrix{Float64}:\n -0.923234   0.372265\n -0.589357   0.610968\n -0.0806012  0.574759\n  0.452539   0.349891\n  0.852191   0.10414","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"(Notice that this weight function is not symmetric, and so the Jacobi matrix is not hollow and the quadrature points and weights are asymmetrically distributed: the  points are denser near x=-1 where the weight function diverges.) These are the same as the Gauss points and weights returned by the gaussjacobi function in FastGaussQuadrature (which has fancy algorithms that scale better for large n than those in QuadGK):","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> xf, wf = FastGaussQuadrature.gaussjacobi(n, α, β); [xf wf]\n5×2 Matrix{Float64}:\n -0.923234   0.372265\n -0.589357   0.610968\n -0.0806012  0.574759\n  0.452539   0.349891\n  0.852191   0.10414\n\njulia> [x w] - [xf wf] # they are same points/weights to nearly machine precision\n5×2 Matrix{Float64}:\n  0.0           3.33067e-16\n  0.0           0.0\n -1.38778e-17  -2.22045e-16\n  5.55112e-17  -2.77556e-16\n -1.11022e-16   9.71445e-17","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"However, QuadGK can also return the 12-point Gauss–Kronrod rule, which embeds/ extends the 5-point Gauss-Jacobi rule in order to give you an error estimate:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> J₁₂ = FastGaussQuadrature.jacobi_jacobimatrix(12, α, β);\n\njulia> kx, kw, gw = kronrod(J₁₂, n, I₁); [kx kw]\n11×2 Matrix{Float64}:\n -0.988882   0.0723663\n -0.923234   0.181321\n -0.786958   0.264521\n -0.589357   0.306879\n -0.347734   0.311949\n -0.0806012  0.286857\n  0.192962   0.238356\n  0.452539   0.175128\n  0.677987   0.109024\n  0.852191   0.0520297\n  0.962303   0.0135914\n\njulia> [ kx[2:2:end] gw ]  # embedded Gauss–Jacobi rule is a subset x₂ᵢ of the points\n5×2 Matrix{Float64}:\n -0.923234   0.372265\n -0.589357   0.610968\n -0.0806012  0.574759\n  0.452539   0.349891\n  0.852191   0.10414","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"The whole point of this is to accelerate convergence for smooth f(x).  For example, let's consider f(x) = cos(2x) with alpha = 05 beta = -01 as above. In this case, according to Mathematica, the correct integral to 100 decimal places is Icos(2x) approx 09016684424525614794498545355301765224191593237834490575027527594933568786176710824696779907143025232764922385146156, or about 0.9016684424525615 to machine precision.  If we use the default quadgk function, which uses adaptive Gauss–Kronod quadrature that doesn't have the singularity built-in, it takes about 1000 function evaluations to reach 9 digits of accuracy:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> exact = 0.9016684424525615;\n\njulia> I, _ = quadgk_count(x -> (1-x)^α * (1+x)^β * cos(2x), -1, 1, rtol=1e-9)\n(0.9016684425015659, 6.535590698106445e-10, 1125)\n\njulia> I - exact\n4.900435612853471e-11","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"(This isn't too terrible! If we plotted the points where quadgk evaluates our integrand, we would see that it concentrates points mostly close to the singularities at the boundaries.  To get a similar error from unweighted Gauss–Legendre quadrature requires about n=10^5 points, which is too slow with the gauss(n) function — it's only practical with x, w = FastGaussQuadrature.gausslegendre(10^5), which uses a fancy O(n) algorithm.  Ordinary Gaussian quadrature very slowly converging for non-smooth functions.) In contrast, our 5-point Gauss–Jacobi quadrature rule from above gets about 6 digits:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> I = sum(@. cos(2x) * w)\n0.9016690323443182\n\njulia> I - exact\n5.898917566637962e-7","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"and gets 10 digits with only 7 points:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> x, w = gauss(FastGaussQuadrature.jacobi_jacobimatrix(7, α, β), I₁);\n\njulia> I = sum(@. cos(2x) * w)\n0.9016684424777912\n\njulia> I - exact\n2.522970721230422e-11","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"This is not unexpected, because the fact that f(x) is smooth means that Gaussian quadrature converges exponentially fast, regardless of the weight function's endpoint singularities (which have been taken into account analytically by the quadrature rule). The Gauss–Kronrod rule also converges exponentially, and gives us an error estimate to give us added confidence in the result.  For example, with our 12-point Gauss–Kronrod rule we obtain the correct result to machine precision:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> Ik = sum(@. cos(2kx) * kw)\n0.9016684424525613\n\njulia> Ik - exact\n-2.220446049250313e-16","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"while a subset kx[2:2:end] of the points (for which we could re-use the integrand evaluations if we wanted) gives us an embedded Gauss rule and an error bound:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> Ig = sum(@. cos(2kx[2:2:end]) * gw)\n0.9016690323443182\n\njulia> abs(Ik - Ig) # conservative error estimate: Kronrod - Gauss\n5.898917568858408e-7","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"As usual, this error bound is quite conservative for smooth f(x) where the quadrature rule is converging rapidly, since it is actually an error estimate for the 5-point Ig and not for the 12-point Ik.  But at least it gives you some indication as to whether you picked a sufficient number of points to integrate f(x) sufficiently accurately.","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"For fun, let's do the same calculation to 100 digits with n=11, using BigFloat arithmetic.  (We simple need to pass big\"0.5\" and big\"-0.1\" for α and β to FastGaussQuadrature and it will construct the Jacobi matrix in BigFloat precision, which QuadGK will then turn into BigFloat Gauss/Gauss–Kronrod points and weights.)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> setprecision(100, base=10)\n100\n\njulia> bigexact = big\"0.9016684424525614794498545355301765224191593237834490575027527594933568786176710824696779907143025232764922385146156\"\n0.901668442452561479449854535530176522419159323783449057502752759493356878617671082469677990714302523252\n\njulia> bigJ = FastGaussQuadrature.jacobi_jacobimatrix(18, big\"0.5\", big\"-0.1\");\n\njulia> bigI₁ = FastGaussQuadrature.jacobimoment(big\"0.5\", big\"-0.1\")\n2.01202309828912479732166203322245014347199888907111184953347045850828228938420405746115463698460502738\n\njulia> bigkx, bigkw, biggw = kronrod(bigJ, 11, bigI₁);\n\njulia> bigIk = sum(@. cos(2bigkx) * bigkw)\n0.901668442452561479449854535530176522419159355847389937592609530571246098597677208391320749304692456157\n\njulia> Float64(bigIk - bigexact)\n3.2063940880089856e-44","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"so the 18-point Gauss–Kronrod rule is accurate to about 43 digits, while the conservative error estimate (= error of embedded 11-point Gauss rule) is about 20 digits:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> bigIg = sum(@. cos(2bigkx[2:2:end]) * biggw)\n0.901668442452561479451864506089616011729536201879100045019491743663463853013435135385929850010604582451\n\njulia> Float64(abs(bigIk - bigIg))\n2.0099705594394893e-21","category":"page"},{"location":"weighted-gauss/#Arbitrary-weight-functions","page":"Weighted quadrature","title":"Arbitrary weight functions","text":"","category":"section"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Although analytical formulas for 3-term recurrences and Jacobi matrices are known for many common types of singularities that appear in integrals, this is certainly not universally true.   As a fallback, you can simply supply an arbitrary weight function W(x) and let QuadGK compute everything for you numerically (essentially by a form of Gram–Schmidt process in which a basis of polynomials is orthonormalized with respect to w, using a sequence of O(n) numerical integrals).   This is much more time consuming, especially if you want high accuracy (i.e. you specify a low tolerance for the numerical integrals), but can be worth it if your f(x) is expensive and/or you need many integrals of a similar form:  the numerical integrals are againt cheap polynomial functions, and are only done once for all f(x) with the same weight function.","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"For example:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"using QuadGK\nx, w = gauss(x -> exp(-x) / sqrt(x), 10, 0, -log(1e-10), rtol=1e-9)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"computes the points and weights for performing ∫exp(-x)f(x)/√x dx integrals from 0 to -log(1e-10) ≈ 23, so that there is a 1/√x singularity in the integrand at x=0 and a rapid decay for increasing x.  (The gauss function currently does not support infinite integration intervals, but for a rapidly decaying weight function you can approximate an infinite interval to any desired accuracy by a sufficiently broad interval, with a tradeoff in computational expense.)  For example, with f(x) = sin(x), the exact answer is 0.570370556005742….  Using the points and weights above with sum(sin.(x) .* w), we obtain 0.5703706212868831, which is correct to 6–7 digits using only 10 f(x) evaluations.  Obtaining similar accuracy for the same integral from quadgk requires nearly 300 function evaluations.   However, the gauss function itself computes many (2n) numerical integrals of your weight function (multiplied by polynomials), so this is only more efficient if your f(x) is very expensive or if you need to compute a large number of integrals with the same W.  See the gauss documentation for more information.","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"Similarly, one can use the kronrod(W, n, a, b, rtol=rtol) function to construct Gauss–Kronrod rules for arbitrary weight functions.   Unfortunately, it turns out that a Gauss–Kronrod rule does not exist for the weight function above, and the kronrod function consequently throws an error — probably because it is very similar to Gauss–Laguerre quadrature and Gauss–Kronrod rules are known to not exist for the Gauss–Laguerre problem (Kahaner & Monegato, 1978).   However, we can for example reproduce the points and weights from the Gauss–Jacobi weight function of the previous section, now computed completely numerically without supplying the analytical Jacobi matrix:","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"julia> kx, kw, gw = kronrod(x -> (1-x)^0.5 * (1+x)^-0.1, 5, -1, 1, rtol=1e-9); [kx kw]\n11×2 Matrix{Float64}:\n -0.988882   0.0723663\n -0.923234   0.181321\n -0.786958   0.264521\n -0.589357   0.306879\n -0.347734   0.311949\n -0.0806012  0.286857\n  0.192962   0.238356\n  0.452539   0.175128\n  0.677987   0.109024\n  0.852191   0.0520297\n  0.962303   0.0135914","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"(If you compare these more quantitatively to those in the previous section, you'll see that they are accurate to about 10 digits, consistent with the rtol=1e-9 that we passed as a tolerance for the numerical integrals used in constructing the Jacobi matrix numerically.)","category":"page"},{"location":"weighted-gauss/","page":"Weighted quadrature","title":"Weighted quadrature","text":"For a more practical example that can only be done numerically, see our tutorial using a weight function interpolated from tabulated solar-spectrum data, also described in Johnson (2019).","category":"page"},{"location":"#QuadGK.jl","page":"Home","title":"QuadGK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements one-dimensional numerical integration (\"quadrature\") in Julia using adaptive Gauss–Kronrod quadrature.","category":"page"},{"location":"","page":"Home","title":"Home","text":"That is, it computes integrals int_a^b f(x) dx numerically, given the endpoints (ab) and an arbitrary function f, to any desired accuracy, using the function quadgk.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(The code was originally part of Base Julia.)","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Features of the QuadGK package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"h-adaptive integration: automatically subdivides the integration integral into smaller segments until a desired accuracy is reached, allowing it to evaluate the integrand more densely in regions where it is badly behaved (e.g. oscillating rapidly).\narbitrary integrand types: the integrand f(x) can return real numbers, complex numbers, vectors, matrices, or any Julia type supporting ±, multiplication by scalars, and norm (i.e. implementing any Banach space).\nArbitrary precision: arbitrary-precision arithmetic types such as BigFloat can be integrated to arbitrary accuracy\n\"Improper\" integrals: Integral endpoints can be pm infty (±Inf in Julia).\nContour integrals: You can specify a sequence of points in the complex plane to perform a contour integral along a piecewise-linear contour.\nArbitrary-order and custom quadrature rules: Any polynomial order of the Gauss–Kronrod quadrature rule can be specified, as well as generating quadrature rules and weights directly; see Gauss and Gauss–Kronrod quadrature rules.  Custom Gaussian-quadrature rules can also be constructed for arbitrary weight functions; see Gaussian quadrature and arbitrary weight functions.\nIn-place integration: For memory efficiency, integrand functions that write in-place into a pre-allocated buffer (e.g. for vector-valued integrands) can be used with the quadgk! function, along with pre-allocated buffers using alloc_segbuf.\nBatched integrand evaluation: Providing an integrand that can evaluate multiple points simultaneously allows for user-controlled parallelization (e.g. using threads, the GPU, or distributed memory).","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following code computes int_0^1 cos(200x) dx numerically, to the default accuracy (a relative error lesssim 10^-8), using quadgk:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using QuadGK\n\njulia> integral, error = quadgk(x -> cos(200x), 0, 1)\n(-0.004366486486069925, 2.552917865170437e-13)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that the result is a tuple of two values: the estimated integral of -0.004366486486069925, an estimated upper bound error ≈ 2.55e-13 on the truncation error in the computed integral (due to the finite number of points at which quadgk evaluates the integrand).","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, quadgk evaluates the integrand at more and more points (\"adaptive quadrature\") until the relative error estimate is less than sqrt(eps()), corresponding to about 8 significant digits.  Often, however, you should change this by passing a relative tolerance (rtol) and/or an absolute tolerance (atol), e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> quadgk(x -> cos(200x), 0, 1, rtol=1e-3)\n(-0.004366486486069085, 2.569238200052031e-6)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For extremely smooth functions like cos(200x), even though it is highly oscillatory, quadgk often gives a very accurate result, even more accurate than the minimum accuracy you requested (defaulting to about 8 digits).  In this particular case, we know that the exact integral is sin(200)200 approx -0004366486486069972908665092105754ldots, and integral matches this to about 14 significant digits with the default tolerance and to about 13 digits even for rtol=1e-3.","category":"page"},{"location":"#Tutorial-examples","page":"Home","title":"Tutorial examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The quadgk examples chapter of this manual presents several other examples, including improper integrals, vector-valued integrands, batched integrand evaluation, improper integrals, singular or near-singular integrands, and Cauchy principal values.","category":"page"},{"location":"#In-place-operations-for-array-valued-integrands","page":"Home","title":"In-place operations for array-valued integrands","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For integrands whose values are small arrays whose length is known at compile-time, it is usually most efficient to modify your integrand to return an SVector from the StaticArrays.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, for integrands that return large or runtime-length arrays, we also provide a function quadgk!(f!, result, a,b...) in order to exploit in-place operations where possible.   The result argument is used to store the estimated integral I in-place, and the integrand function is now of the form f!(r, x) and should write f(x) in-place into the result array r.  See the quadgk! documentation for more detail.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the API reference chapter for a detailed description of the QuadGK programming interface.","category":"page"},{"location":"#Other-Julia-quadrature-packages","page":"Home","title":"Other Julia quadrature packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The FastGaussQuadrature.jl package provides non-adaptive Gaussian quadrature variety of built-in weight functions — it is a good choice you need to go to very high orders N, e.g. to integrate rapidly oscillating functions, or use weight functions that incorporate some standard singularity in your integrand.  QuadGK, on the other hand, keeps the order N of the quadrature rule fixed and improves accuracy by subdividing the integration domain, which can be better if fine resolution is required only in a part of your domain (e.g if your integrand has a sharp peak or singularity somewhere that is not known in advance).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For multidimensional integration, see also the HCubature.jl, Cubature.jl, and Cuba.jl packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that all of the above quadrature routines assume that you supply you integrand as a function f(x) that can be evaluated at arbitrary points inside the integration domain.  This is ideal, because then the integration algorithm can choose points so that the accuracy improves rapidly (often exponentially rapidly) with the number of points.   However if you only have function values supplied at pre-determined points, such as on a regular grid, then you should use another (probably slower-converging) algorithm in a package such as Trapz.jl, Romberg.jl, or NumericalIntegration.jl.","category":"page"}]
}
