var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-reference","page":"Reference","title":"Function reference","text":"","category":"section"},{"location":"functions/","page":"Reference","title":"Reference","text":"The following are the functions exported by the QuadGK package:","category":"page"},{"location":"functions/","page":"Reference","title":"Reference","text":"QuadGK.quadgk\nQuadGK.quadgk_count\nQuadGK.quadgk_print\nQuadGK.quadgk!\nQuadGK.gauss\nQuadGK.kronrod\nQuadGK.alloc_segbuf","category":"page"},{"location":"functions/#QuadGK.quadgk","page":"Reference","title":"QuadGK.quadgk","text":"quadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)\n\nNumerically integrate the function f(x) from a to b, and optionally over additional intervals b to c and so on. Keyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the endpoints), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nReturns a pair (I,E) of the estimated integral I and an estimated upper bound on the absolute error E. If maxevals is not exceeded then E <= max(atol, rtol*norm(I)) will hold. (Note that it is useful to specify a positive atol in cases where norm(I) may be zero.)\n\nThe endpoints a et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are BigFloat, then the integration will be performed in BigFloat precision as well.\n\nnote: Note\nIt is advisable to increase the integration order in rough proportion to the precision, for smooth integrands.\n\nMore generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand f(x) can return any numeric scalar, vector, or matrix type, or in fact any type supporting +, -, multiplication by real values, and a norm (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a norm-like function as the norm keyword argument (which defaults to norm).\n\nnote: Note\nOnly one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if f has a discontinuity at x=0.7 and you want to integrate from 0 to 1, you should use quadgk(f, 0,0.7,1) to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a log(x) or 1/sqrt(x) singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\nIn normal usage, quadgk(...) will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using alloc_segbuf(...) as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"functions/#QuadGK.quadgk_count","page":"Reference","title":"QuadGK.quadgk_count","text":"quadgk_count(f, args...; kws...)\n\nIdentical to quadgk but returns a triple (I, E, count) of the estimated integral I, the estimated error bound E, and a count of the number of times the integrand f was evaluated.\n\nThe count of integrand evaluations is a useful performance metric, a large number typically indicates a badly behaved integrand (with singularities, discontinuities, sharp peaks, and/or rapid oscillations), in which case it may be possible to mathematically transform the problem in some way to improve the convergence rate.\n\n\n\n\n\n","category":"function"},{"location":"functions/#QuadGK.quadgk_print","page":"Reference","title":"QuadGK.quadgk_print","text":"quadgk_print([io], f, args...; kws...)\n\nIdentical to quadgk, but prints each integrand evaluation to the stream io (defaults to stdout) in the form:\n\nf(x1) = y1\nf(x2) = y2\n...\n\nwhich is useful for pedagogy and debugging.\n\nAlso, like quadgk_count, it returns a triple (I, E, count) of the estimated integral I, the estimated error bound E, and a count of the number of times the integrand f was evaluated.\n\n\n\n\n\n","category":"function"},{"location":"functions/#QuadGK.quadgk!","page":"Reference","title":"QuadGK.quadgk!","text":"quadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)\n\nLike quadgk, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from quadgk:\n\nThe function f! should be of the form f!(y, x) = y .= f(x).  That is, it writes the return value of the integand f(x) in-place into its first argument y.   (The return value of f! is ignored.)\nLike quadgk, the return value is a tuple (I,E) of the estimated integral I and the estimated error E.   However, in quadgk! the estimated integral is written in-place into the result argument, so that I === result.\n\nOtherwise, the behavior is identical to quadgk.\n\nFor integrands whose values are small arrays whose length is known at compile-time, it is usually more efficient to use quadgk and modify your integrand to return an SVector from the StaticArrays.jl package.\n\n\n\n\n\n","category":"function"},{"location":"functions/#QuadGK.gauss","page":"Reference","title":"QuadGK.gauss","text":"gauss([T,] N, a=-1, b=1)\n\nReturn a pair (x, w) of N quadrature points x[i] and weights w[i] to integrate functions on the interval (a, b),  i.e. sum(w .* f.(x)) approximates the integral.  Uses the method described in Trefethen & Bau, Numerical Linear Algebra, to find the N-point Gaussian quadrature in O(N²) operations.\n\nT is an optional parameter specifying the floating-point type, defaulting to Float64. Arbitrary precision (BigFloat) is also supported.\n\n\n\n\n\ngauss(W, N, a, b; rtol=sqrt(eps), quad=quadgk)\n\nReturn a pair (x, w) of N quadrature points x[i] and weights w[i] to integrate functions on the interval (a, b) multiplied by the weight function W(x).  That is, sum(w .* f.(x)) approximates the integral ∫ W(x)f(x)dx from a to b.\n\nThis function performs 2N numerical integrals of polynomials against W(x) using the integration function quad (defaults to quadgk) with relative tolerance rtol (which defaults to half of the precision eps of the endpoints). This is followed by an O(N²) calculations. So, using a large order N is expensive.\n\nIf W has lots of singularities that make it hard to integrate numerically, you may need to decrease rtol.   You can also pass in a specialized quadrature routine via the quad keyword argument, which should accept arguments quad(f,a,b,rtol=_,atol=_) similar to quadgk.  (This is useful if your weight function has discontinuities, in which case you might want to break up the integration interval at the discontinuities.)\n\n\n\n\n\n","category":"function"},{"location":"functions/#QuadGK.kronrod","page":"Reference","title":"QuadGK.kronrod","text":"kronrod([T,] n)\n\nCompute 2n+1 Kronrod points x and weights w based on the description in Laurie (1997), appendix A, simplified for a=0, for integrating on [-1,1]. Since the rule is symmetric, this only returns the n+1 points with x <= 0. The function Also computes the embedded n-point Gauss quadrature weights gw (again for x <= 0), corresponding to the points x[2:2:end]. Returns (x,w,wg) in O(n²) operations.\n\nT is an optional parameter specifying the floating-point type, defaulting to Float64. Arbitrary precision (BigFloat) is also supported.\n\nGiven these points and weights, the estimated integral I and error E can be computed for an integrand f(x) as follows:\n\nx, w, wg = kronrod(n)\nfx⁰ = f(x[end])                # f(0)\nx⁻ = x[1:end-1]                # the x < 0 Kronrod points\nfx = f.(x⁻) .+ f.((-).(x⁻))    # f(x < 0) + f(x > 0)\nI = sum(fx .* w[1:end-1]) + fx⁰ * w[end]\nif isodd(n)\n    E = abs(sum(fx[2:2:end] .* wg[1:end-1]) + fx⁰*wg[end] - I)\nelse\n    E = abs(sum(fx[2:2:end] .* wg[1:end])- I)\nend\n\n\n\n\n\n","category":"function"},{"location":"functions/#QuadGK.alloc_segbuf","page":"Reference","title":"QuadGK.alloc_segbuf","text":"function alloc_segbuf(domain_type=Float64, range_type=Float64, error_type=Float64; size=1)\n\nThis helper will allocate a segment buffer for segments to a quadgk(...) call with the given domain_type, which is the same as the type of the integration limits, range_type i.e. the range of the function being integrated and error_type, the type returned by the norm given to quadgk(...) and starting with the given size. The buffer can then be reused across multiple compatible calls to quadgk(...) to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"quadgk-examples/#quadgk-examples","page":"Examples","title":"quadgk examples","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The following are several examples illustrating the usage of the main quadgk numerical-integration function of QuadGK, focusing on more complicated circumstances than the smooth scalar integral of the Quick start section.","category":"page"},{"location":"quadgk-examples/#Improper-integrals:-Infinite-limits","page":"Examples","title":"Improper integrals: Infinite limits","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"quadgk supports \"improper\" integrals over infinite and semi-infinite intervals, simply by passing ±Inf for the endpoints.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, int_0^infty e^-x dx = 1 is computed by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> exp(-x), 0, Inf)\n(1.0, 4.507383379289404e-11)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which give gives the correct answer (1) exactly in this case.  Note that the error estimate ≈ 4.5e-11 is pessimistic, as is often the case.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The Gaussian integral int_-infty^+infty e^-x^2 dx = sqrtpi = 1772453850905516027298167483341ldots is computed by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> exp(-x^2), -Inf, Inf)\n(1.7724538509055137, 6.4296367126505234e-9)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which is the correct answer to nearly machine precision, despite the pessimistic error estimate ≈ 6.4e-9.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Internally, quadgk handles infinite limits by the changes of variables","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"int_a^infty f(x)dx = int_0^1 fleft(a + fract1-tright) frac1(1-t)^2 dt","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"and","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"int_-infty^infty f(x)dx = int_-1^1 fleft(fract1-t^2right) frac1+t^2(1-t^2)^2 dt","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"respectively.   Although the transformed integrands are singular at the endpoints t = 1 and t = pm 1, respectively, because the singularities are integrable and quadgk never evaluates the integrand exactly at the endpoints, it is able to perform the numerical integration successfully.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Important tip: This change-of-variables trick works best if your function decays with x over a lengthscale of order sim 1. If your decay length is much larger or shorter than that, it will perform poorly.  For example, with f(x) = e^-x10^6 the decay is over a lengthscale sim 10^6 and quadgk requires many more evaluations (705) than for e^-x (135, as measured by quadgk_count, described below):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> exp(-x), 0, Inf)\n(1.0, 4.507382674563286e-11, 135)\n\njulia> quadgk_count(x -> exp(-x/1e6), 0, Inf)\n(1.000000000001407e6, 0.0014578728207218505, 705)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"If your function decays over a lengthscale sim L, it is a good idea to compute improper integrals using a change of variables int_a^b f(x)dx = int_aL^bL f(uL) L  du, for example:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> L = 1e6 # decay lengthscale\n1.0e6\n\njulia> f(x) = exp(-x/L)\nf (generic function with 1 method)\n\njulia> quadgk_count(u -> f(u*L) * L, 0, Inf) # rescaled integration over u = x/L\n(1.0e6, 4.507388807828416e-5, 135)","category":"page"},{"location":"quadgk-examples/#Counting-and-printing-integrand-evaluations","page":"Examples","title":"Counting and printing integrand evaluations","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Often, it is a good idea to count the number of times the integrand is evaluated, in order to have a sense of how efficiently quadgk is performing the integral; this is especially useful with badly behaved integrand (e.g. with singularities, discontinuities, sharp spikes, and/or rapid oscillations) to see whether some transformation of the problem might be helpful (see below).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"This is easy enough by simply incrementing a global counter in your integrand function and printing progress as desired.    But it is such a common desire in pedagogy and debugging that we provide convenience functions quadgk_count and quadgk_print to automate this task.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, in our int_0^infty e^-x dx example from above, we could do:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> exp(-x), 0, Inf)\n(1.0, 4.507383379289404e-11, 135)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"to return the number of function evaluations (135) along with the integral (1.0) and error estimate (≈ 4.5e-11).   A relatively large number of function evaluations are required, even though the function e^-x is very smooth, because the infinite endpoint implicitly introduces a singularity (via the change of variables discussed above).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"We can also print the evaluation points, setting a lower requested relative accuracy of rtol=1e-2 so that we don't get so much output, by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_print(x -> exp(-x), 0, Inf, rtol=1e-2)\nf(1.0 = 0.36787944117144233\nf(0.655923922306948 = 0.5189623601162878\nf(1.52456705113438 = 0.21771529605384055\nf(0.026110451522445993 = 0.9742274787577301\nf(38.29883980138536 = 2.3282264081806294e-17\nf(0.00429064542600238 = 0.9957185462423211\nf(233.06516868994527 = 6.04064500678147e-102\nf(0.14841469193194298 = 0.8620735458624529\nf(6.737877409458626 = 0.0011851600983136456\nf(0.07246402202084404 = 0.9300992091482783\nf(13.799951646519888 = 1.015680581505947e-6\nf(0.42263178703605514 = 0.6553198859704107\nf(2.3661258586654506 = 0.09384358625528809\nf(0.26096469051417465 = 0.7703081183184751\nf(3.831936029467112 = 0.021667625834125973\n(0.9999887201849575, 0.0009180738585039538, 15)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"to see that (for a relatively low requested relative accuracy of rtol=1e-2) it evaluates the integrand only 15 times at points from x approx 000429 to x approx 2331, and still managed to get about 5 significant digits correct.  (Note that quadgk_print again returns a 3-element tuple, like quadgk_count, where the third element is the number of integrand evaluations.)","category":"page"},{"location":"quadgk-examples/#Integrands-with-singularities-and-discontinuities","page":"Examples","title":"Integrands with singularities and discontinuities","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The integral int_0^1 x^-12 dx = left 2 sqrtx right_0^1 = 2 is perfectly finite even though the integrand 1sqrtx blows up at x=0.  This is an example of an integrable singularity, and quadgk can compute this integral:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> 1/sqrt(x), 0, 1)\n(1.9999999845983916, 2.3762511924588765e-8, 1305)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Notice the large number (1305) of integrand evaluations returned by quadgk_count: this is an indication of how much more work it is to evaluate an integral with a singularity or any other form of non-smoothness. At its heart, the Gauss–Kronrod algorithm employed by quadgk works by interpolating the integrand with polynomials over segments of the domain, and polynomials are bad at representing non-analytic functions like 1sqrtx.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The good news is that quadgk never evaluates functions exactly at the endpoints, so it is okay if your function blows up or errors at those points.   However, this means that if you function blows up in the interior of the integration domain, you should add an extra \"endpoint\" at that point to make sure we never evaluate it. (Also, quadgk can often converge more quickly if you tell it where your singularities are via the endpoints.)  For example, suppose we are integrating int_0^2 x-1^-12 dx = 4, which has an (integrable) singularity at x=1. If we don't tell quadgk about the singularity, it gets \"unlucky\" and evaluates the integrand exactly at x=1, which ends up throwing an error:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> 1/sqrt(abs(x-1)), 0, 2)\nERROR: DomainError with 1.0:\nintegrand produced NaN in the interval (0, 2)\n...","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Instead, if we tell it to subdivide the integral at x=1, we get the correct answer(≈ 4):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> 1/sqrt(abs(x-1)), 0, 1, 2)\n(3.9999999643041515, 5.8392038954259235e-8, 2580)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"In general, the syntax quadgk(f, a, b, c, ...) denotes the integral int_a^b f(x)dx + int_b^c f(x)dx  + cdots, and quadgk never evaluates the integrand f(x) exactly at the endpoints a b c ldots.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As another example, consider an integral int_0^3 H(x-1) = 2 of the discontinuous Heaviside step function H(x), which =1 when x  0 and =0 when x le 0:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> x > 1, 0, 3)\n(2.0000000043200235, 1.7916158219741817e-8, 705)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Even though H(x-1) is nearly constant, quadgk struggles to integrate it (705 function evaluations to get about 8 digits), thanks to the discontinuity at x=1. (Note that true and false in Julia are equal to numeric 0 and 1, which is why we could implement H(x-1) as simply x > 1.) On the other hand, if we tell it the location of the discontinuity:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> x > 1, 0, 1, 3)\n(2.0, 0.0, 30)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"then it gives the exact answer in only 30 evaluations.  The reason it takes 30 evaluations is because quadgk defaults to 7th-order Gauss–Kronrod integration rule, which uses 15 points to interpolate with a high-degree polynomial.  Once we subdivide the integral, we could actually get away with a lower-order rule by setting the order parameter, e.g.:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> x > 1, 0, 1, 3, order=1)\n(2.0, 0.0, 6)","category":"page"},{"location":"quadgk-examples/#Complex-and-vector-valued-integrands","page":"Examples","title":"Complex and vector-valued integrands","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The integrand f(x) can return not just real numbers, but also complex numbers, vectors, matrices, or any Julia type supporting ±, multiplication by scalars, and norm (i.e. implementing any Banach space).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, we can integrate 1sqrtx from x=-1 to x=1, where we tell the sqrt function to return a complex result for negative arguments:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> 1/sqrt(complex(x)), -1, 0, 1)\n(1.9999999891094182 - 1.9999999845983916im, 4.056765398346683e-8)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which correctly gives approx 2 - 2i.  Note that we explicitly put an endpoint at x=0 to tell quadgk about the singularity at that point, as described above.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Or let's integrate the vector-valued function f(x) = 1 x x^2 x^3 for x in (01):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> [1,x,x^2,x^3], 0, 1)\n([1.0, 0.5, 0.3333333333333333, 0.25], 6.206335383118183e-17)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which correctly returns approx 1 frac12 frac13 frac14.  Note that the error estimate in this case is an approximate bound on the norm of the error, as computed by the LinearAlgebra.norm function in Julia.  It defaults to the Euclidean (L2) norm, but you can change this with the norm argument:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(x -> [1,x,x^2,x^3], 0, 1, norm=v->maximum(abs, v))\n([1.0, 0.5, 0.3333333333333333, 0.25], 5.551115123125783e-17)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"e.g. to use the maximum norm or some other norm (e.g. a weighted norm if the different components have different units or have unequal error tolerances).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For integrands whose values are small arrays whose length is known at compile time, it is usually most efficient to modify your integrand to return an SVector from the StaticArrays.jl package.  For the example above:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> using StaticArrays\n\njulia> integral, error = quadgk(x -> @SVector[1,x,x^2,x^3], 0, 1)\n([1.0, 0.5, 0.3333333333333333, 0.25], 6.206335383118183e-17)\n\njulia> typeof(integral)\nSVector{4, Float64} (alias for SArray{Tuple{4}, Float64, 1, 4})","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Note that the return value also gives the integral as an SVector (a statically sized array).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The QuadGK package did not need any code specific to StaticArrays, and was written long before that package even existed.  The fact that unrelated packages like this can be composed is part of the beauty of multiple dispatch and duck typing for generic programming.","category":"page"},{"location":"quadgk-examples/#Arbitrary-precision-integrals","page":"Examples","title":"Arbitrary-precision integrals","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"quadgk also supports arbitrary-precision arithmetic using Julia's BigFloat type to compute integrals to arbitrary accuracy (albeit at increased computational cost).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, we can compute the error function fracsqrtpi2 texterf(1) = int_0^1 e^-x^2 dx to 50 digits by:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> setprecision(60, base=10) # use 60-digit arithmetic\n60\n\njulia> quadgk_count(x -> exp(-x^2), big\"0.0\", big\"1.0\", rtol=1e-50)\n(0.74682413281242702539946743613185300535449968681260632902766195, 6.8956257635323481758755998484087241330474674891762053644928492e-51, 15345)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"The correct answer is ≈ 0.746824132812427025399467436131853005354499686812606329027654498958605…, and we are matching that to nearly the full precision (≈ 60 digits).  (As usual, the error estimate of quadgk is very conservative for smooth functions.)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Unfortunately, it took 15345 function evaluations to obtain such an accurate answer.  Since this a smooth integrand, for high-accuracy calculations it is often advisable to increase the \"order\" of the quadrature algorithm (which is related to the degree of polynomials used for interpolation).  The default is order=7, but let's try tripling it to order=21:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk_count(x -> exp(-x^2), big\"0.0\", big\"1.0\", rtol=1e-50, order=21)\n(0.74682413281242702539946743613185300535449968681260632902765324, 2.1873898701681913100611385149037136705674736373054902472850425e-58, 129)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"It got the same accuracy (≈ 60 digits) with only 129 integrand evaluations!","category":"page"},{"location":"quadgk-examples/#Contour-integration","page":"Examples","title":"Contour integration","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"You can specify a sequence of points in the complex plane to perform a contour integrals with quadgk along a piecewise-linear contour.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, consider the function f(z) = cos(z)z.  By the residue theorem of complex analysis, if we integrate counter-clockwise in a \"loop\" around the pole at z=0, we should get exactly 2pi i cos(0) = 2pi i.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"One way to do this integral is to parameterize a contour, say a circle z=1 parameterized by z= e^iphi (= cis(ϕ) in Julia), which gives dz = i z dphi, to obtain an ordinary integral int_0^2pi fraccos(e^iphi)e^iphi ie^iphi dphi over the real parameter phi in (02pi):","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(ϕ -> cos(cis(ϕ)) * im, 0, 2π)\n(0.0 + 6.283185307179586im, 1.8649646913725044e-8)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which indeed gives us approx 2pi i (to machine precision).","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As an alternative, however, you can directly supply a sequence of complex \"endpoints\" to quadgk and it will perform the contour integral along a sequence of line segments connecting these points.  For example, instead of integrating around a circular contour, we can integrate around the diamond (rotated square) connecting the corners pm 1 and pm i:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> quadgk(z -> cos(z)/z, 1, im, -1, -im, 1)\n(0.0 + 6.283185307179587im, 5.369976662961913e-9)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which again gives approx 2pi i (to machine precision).  Note that it is critically important to have a closed contour (a loop): the final endpoint must be the same as the starting point (z=1).","category":"page"},{"location":"quadgk-examples/#Cauchy-principal-values","page":"Examples","title":"Cauchy principal values","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Integrands f(x) = g(x)x that diverge sim 1x cannot be integrated through x=0 in the usual way (the singularity is not integrable). However, if you integrate around x=0, for both signs of x, then you can define a kind of integral that is the \"difference\" of the divergence on the two sides.  This definition is called a Cauchy principal value, and is usually presented as a limit:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"textpvint_a^b fracg(x)x dx =\nlim_varepsilonto 0^+ left\n    int_a^-varepsilon fracg(x)x dx + int_+varepsilon^b fracg(x)x dx\nright  ","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"That is, you subtract a \"ball\" of radius varepsilon from the integration domain a  0  b to eliminate the singularity at x=0, and take the limit of the resulting integral as the varepsilon goes to zero.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"In principle, you might imagine taking this limit numerically by extrapolation of numerical integrals for a sequence of varepsilon  0 values, perhaps using Richardson extrapolation via the Richardson.jl package.  However, it is mathematically equivalent and much more efficient to use a simple singularity-subtraction procedure:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"fracg(x)x  =\nfracg(x)-g(0)x + fracg(0)x","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"where the first term is not singular if g(x) is differentiable at x=0, and the latter term can be integrated analytically, giving:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"textpvint_a^b fracg(x)x dx = int_a^b fracg(x)-g(0)x dx +\ng(0) logba","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Since the remaining integral has no singularity, we can do it numerically directly.  There are two tricks to help us a bit further:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As in Integrands with singularities and discontinuities above, we'll want to put an extra endpoint at x=0 to make sure quadgk doesn't evaluate the integrand exactly at that point (which would give NaN from 00).\nWe should be careful with the integration tolerances, to make sure that any relative tolerance rtol is applied with respect to the whole principal part and not just to the g(x)-g(0) integral.  An easy way to do this is to add g(0) fraclogbab-a to the integrand, so that we no longer compute the two pieces separately.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Putting it all together, here is a function cauchy_quadgk(g, a, b) that computes our Cauchy principal part textpvint_a^b g(x)x:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"function cauchy_quadgk(g, a, b; kws...)\n    a < 0 < b || throw(ArgumentError(\"domain must include 0\"))\n    g₀ = g(0)\n    g₀int = b == -a ? zero(g₀) : g₀ * log(abs(b/a)) / (b - a)\n    return quadgk_count(x -> (g(x)-g₀)/x + g₀int, a, 0, b; kws...)\nend","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, Mathematica tells us that","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"textpv int_-1^2 fraccos(x^2-1)x dx approx 0212451309942989788929352736695ldots ","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"and we can reproduce this with cauchy_quadgk:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> cauchy_quadgk(x -> cos(x^2-1), -1, 2)\n(0.21245130994298977, 1.8366794196644776e-11, 60)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which is correct to about 16 digits.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"This approach and other approaches to computing Cauchy principal values are discussed in Keller and Wróbel (2016). This kind of \"singularity subtraction\" is a powerful approach to efficient computation of integrals with singularities or near singularities. A huge variety of related techniques have been developed for boundary element methods, where a vast number of singular integrals must be computed and efficiency is at a premium.  See, for example, Reid et al. (2014) and references therein.","category":"page"},{"location":"quadgk-examples/#Nearly-singular-integrands","page":"Examples","title":"Nearly singular integrands","text":"","category":"section"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"Even if the integrand is only nearly singular, so that there is a sharp but finite peak within the integration domain, it can greatly increase the efficiency of numerical integration if you can separate the sharp peak analytically.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"For example, suppose that you are integrating:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"I = int_a^b fracg(x)x - ialpha dx","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"for a small 0  alpha ll 1.  For alpha to 0^+, it approaches ipi g(0) plus a Cauchy principal part (the latter being zero if a = -b and g(x)=g(-x)), but for small alpha  0 you have to numerically integrate (for a general function g(x)) a function with a sharp spike at x=0, which will require a large number of quadrature points.  But you can subtract out the singularity analytically:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"I = int_a^b left fracg(x)-g(0)x - ialpha + fracg(0)x - ialpha right dx \n= int_a^b fracg(x)-g(0)x - ialphadx + underbraceg(0) leftfrac12log(x^2 + alpha^2) + itan^-1(xalpha) right_a^b_I_0","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"and then you only need to numerically integrate I - I_0, which has the spike subtracted.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As for Cauchy principal values above, we want to include a I_0  (b-a) term directly in the integrand so that the error tolerances are computed correctly, and include x=0 as an explicit endpoint to let quadgk know that the integral is badly behaved there.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"In code:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"using QuadGK\n\nfunction int_slow(g, α, a, b; kws...)\n    if a < 0 < b\n        # put an explicit endpoint at x=0 since we know it is badly behaved there\n        return quadgk_count(x -> g(x) / (x - im*α), a, 0, b; kws...)\n    else\n        return quadgk_count(x -> g(x) / (x - im*α), a, b; kws...)\n    end\nend\n\nfunction int_fast(g, α, a, b; kws...)\n    g₀ = g(0)\n    denom_int(x) = log(x^2 + α^2)/2 + im * atan(x/α)\n    I₀ = g₀ * (denom_int(b) - denom_int(a))\n    if a < 0 < b\n        # put an explicit endpoint at x=0 since we know it is badly behaved there\n        (I,E,c) = quadgk_count(x -> I₀/(b-a) + (g(x) - g₀) / (x - im*α), a, 0, b; kws...)\n    else\n        (I,E,c) = quadgk_count(x -> I₀/(b-a) + (g(x) - g₀) / (x - im*α), a, b; kws...)\n    end\n    return (I,E,c+1) # add 1 for g(0) evaluation\nend","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"This gives:","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"julia> int_slow(cos, 1e-6, -1, 1)\n(1.1102230246251565e-16 + 3.1415896808206125im, 1.4895091715264936e-9, 1230)\n\njulia> int_fast(cos, 1e-6, -1, 1)\n(3.3306690738754696e-16 + 3.1415896808190418im, 1.8459683038047577e-12, 31)","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"which agree to about 13 digits, but the slow brute-force method requires 1230 function evaluations while the fast singularity-subtracted method requires only 31 function evaluations.","category":"page"},{"location":"quadgk-examples/","page":"Examples","title":"Examples","text":"As an added bonus, int_fast works even for α = 0, where it gives you ipi g(0) (for 0 in (ab)) plus the Cauchy principal part as above.","category":"page"},{"location":"weighted-gauss/#Gaussian-quadrature-and-arbitrary-weight-functions","page":"Weighted Gauss","title":"Gaussian quadrature and arbitrary weight functions","text":"","category":"section"},{"location":"weighted-gauss/","page":"Weighted Gauss","title":"Weighted Gauss","text":"If you are computing many similar integrals of smooth functions, you may not need an adaptive integration — with a little experimentation, you may be able to decide on an appropriate number N of integration points in advance, and re-use this for all of your integrals.    In this case you can use x, w = gauss(N, a, b) to find the quadrature points x and weights w, so that sum(f.(x) .* w) is an N-point approximation to ∫f(x)dx from a to b.","category":"page"},{"location":"weighted-gauss/","page":"Weighted Gauss","title":"Weighted Gauss","text":"For computing many integrands of similar functions with singularities, x, w = gauss(W, N, a, b) function allows you to pass a weight function W(x) as the first argument, so that sum(f.(x) .* w) is an N-point approximation to ∫W(x)f(x)dx from a to b.   In this way, you can put all of the singularities etcetera into W and precompute an accurate quadrature rule as long as the remaining f(x) terms are smooth.   For example,","category":"page"},{"location":"weighted-gauss/","page":"Weighted Gauss","title":"Weighted Gauss","text":"using QuadGK\nx, w = gauss(x -> exp(-x) / sqrt(x), 10, 0, -log(1e-10), rtol=1e-9)","category":"page"},{"location":"weighted-gauss/","page":"Weighted Gauss","title":"Weighted Gauss","text":"computes the points and weights for performing ∫exp(-x)f(x)/√x dx integrals from 0 to -log(1e-10) ≈ 23, so that there is a 1/√x singularity in the integrand at x=0 and a rapid decay for increasing x.  (The gauss function currently does not support infinite integration intervals, but for a rapidly decaying weight function you can approximate an infinite interval to any desired accuracy by a sufficiently broad interval, with a tradeoff in computational expense.)  For example, with f(x) = sin(x), the exact answer is 0.570370556005742….  Using the points and weights above with sum(sin.(x) .* w), we obtain 0.5703706212868831, which is correct to 6–7 digits using only 10 f(x) evaluations.  Obtaining similar accuracy for the same integral from quadgk requires nearly 300 function evaluations.   However, the gauss function itself computes many (2N) numerical integrals of your weight function (multiplied by polynomials), so this is only more efficient if your f(x) is very expensive or if you need to compute a large number of integrals with the same W.","category":"page"},{"location":"weighted-gauss/","page":"Weighted Gauss","title":"Weighted Gauss","text":"See the gauss documentation for more information.  See also our example using a weight function interpolated from tabulated data.","category":"page"},{"location":"#QuadGK.jl","page":"Home","title":"QuadGK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements one-dimensional numerical integration (\"quadrature\") in Julia using adaptive Gauss–Kronrod quadrature.","category":"page"},{"location":"","page":"Home","title":"Home","text":"That is, it computes integrals int_a^b f(x) dx numerically, given the endpoints (ab) and an arbitrary function f, to any desired accuracy, using the function quadgk.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(The code was originally part of Base Julia.)","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Features of the QuadGK package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"h-adaptive integration: automatically subdivides the integration integral into smaller segments until a desired accuracy is reached, allowing it to evaluate the integrand more densely in regions where it is badly behaved (e.g. oscillating rapidly).\narbitrary integrand types: the integrand f(x) can return real numbers, complex numbers, vectors, matrices, or any Julia type supporting ±, multiplication by scalars, and norm (i.e. implementing any Banach space).\nArbitrary precision: arbitrary-precision arithmetic types such as BigFloat can be integrated to arbitrary accuracy\n\"Improper\" integrals: Integral endpoints can be pm infty (±Inf in Julia).\nContour integrals: You can specify a sequence of points in the complex plane to perform a contour integral along a piecewise-linear contour.\nArbitrary-order and custom quadrature rules: Any polynomial order of the Gauss–Kronrod quadrature rule can be specified, and custom Gaussian-quadrature rules can be constructed for arbitrary weight functions.  See Gaussian quadrature and arbitrary weight functions.\nIn-place integration: For memory efficiency, integrand functions that write in-place into a pre-allocated buffer (e.g. for vector-valued integrands) can be used with the quadgk! function, along with pre-allocated buffers using alloc_segbuf.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following code computes int_0^1 cos(200x) dx numerically, to the default accuracy (a relative error lesssim 10^-8), using quadgk:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using QuadGK\n\njulia> integral, error = quadgk(x -> cos(200x), 0, 1)\n(-0.004366486486069925, 2.552917865170437e-13)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that the result is a tuple of two values: the estimated integral of -0.004366486486069925, an estimated upper bound error ≈ 2.55e-13 on the truncation error in the computed integral (due to the finite number of points at which quadgk evaluates the integrand).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For extremely smooth functions like cos(200x), even though it is highly oscillatory, quadgk often gives a very accurate result, even more accurate than the minimum accuracy you requested (defaulting to about 8 digits).  In this particular case, we know that the exact integral is sin(200)200 approx -0004366486486069972908665092105754ldots, and integral matches this to about 14 significant digits.","category":"page"},{"location":"#Tutorial-examples","page":"Home","title":"Tutorial examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The quadgk examples chapter of this manual presents several other examples, including improper integrals, vector-valued integrands, improper integrals, singular or near-singular integrands, and Cauchy principal values.","category":"page"},{"location":"#In-place-operations-for-array-valued-integrands","page":"Home","title":"In-place operations for array-valued integrands","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For integrands whose values are small arrays whose length is known at compile-time, it is usually most efficient to modify your integrand to return an SVector from the StaticArrays.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, for integrands that return large or runtime-length arrays, we also provide a function quadgk!(f!, result, a,b...) in order to exploit in-place operations where possible.   The result argument is used to store the estimated integral I in-place, and the integrand function is now of the form f!(r, x) and should write f(x) in-place into the result array r.  See the quadgk! documentation for more detail.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Function reference chapter for a detailed description of the QuadGK programming interface.","category":"page"},{"location":"#Other-Julia-quadrature-packages","page":"Home","title":"Other Julia quadrature packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The FastGaussQuadrature.jl package provides non-adaptive Gaussian quadrature variety of built-in weight functions — it is a good choice you need to go to very high orders N, e.g. to integrate rapidly oscillating functions, or use weight functions that incorporate some standard singularity in your integrand.  QuadGK, on the other hand, keeps the order N of the quadrature rule fixed and improves accuracy by subdividing the integration domain, which can be better if fine resolution is required only in a part of your domain (e.g if your integrand has a sharp peak or singularity somewhere that is not known in advance).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For multidimensional integration, see also the HCubature.jl, Cubature.jl, and Cuba.jl packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that all of the above quadrature routines assume that you supply you integrand as a function f(x) that can be evaluated at arbitrary points inside the integration domain.  This is ideal, because then the integration algorithm can choose points so that the accuracy improves rapidly (often exponentially rapidly) with the number of points.   However if you only have function values supplied at pre-determined points, such as on a regular grid, then you should use another (probably slower-converging) algorithm in a package such as Trapz.jl, Romberg.jl, or NumericalIntegration.jl.","category":"page"}]
}
