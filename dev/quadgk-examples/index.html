<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · QuadGK.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuadGK.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Improper-integrals:-Infinite-limits"><span>Improper integrals: Infinite limits</span></a></li><li><a class="tocitem" href="#Counting-and-printing-integrand-evaluations"><span>Counting and printing integrand evaluations</span></a></li><li><a class="tocitem" href="#Integrands-with-singularities-and-discontinuities"><span>Integrands with singularities and discontinuities</span></a></li><li><a class="tocitem" href="#Complex-and-vector-valued-integrands"><span>Complex and vector-valued integrands</span></a></li><li><a class="tocitem" href="#Batched-integrand-evaluation"><span>Batched integrand evaluation</span></a></li><li><a class="tocitem" href="#Arbitrary-precision-integrals"><span>Arbitrary-precision integrals</span></a></li><li><a class="tocitem" href="#Contour-integration"><span>Contour integration</span></a></li><li><a class="tocitem" href="#Cauchy-principal-values"><span>Cauchy principal values</span></a></li><li><a class="tocitem" href="#Nearly-singular-integrands"><span>Nearly singular integrands</span></a></li></ul></li><li><a class="tocitem" href="../gauss-kronrod/">Quadrature rules</a></li><li><a class="tocitem" href="../weighted-gauss/">Weighted quadrature</a></li><li><a class="tocitem" href="../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/QuadGK.jl/blob/master/docs/src/quadgk-examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="quadgk-examples"><a class="docs-heading-anchor" href="#quadgk-examples"><code>quadgk</code> examples</a><a id="quadgk-examples-1"></a><a class="docs-heading-anchor-permalink" href="#quadgk-examples" title="Permalink"></a></h1><p>The following are several examples illustrating the usage of the main <a href="../api/#QuadGK.quadgk"><code>quadgk</code></a> numerical-integration function of QuadGK, focusing on more complicated circumstances than the smooth scalar integral of the <a href="../#Quick-start">Quick start</a> section.</p><h2 id="Improper-integrals:-Infinite-limits"><a class="docs-heading-anchor" href="#Improper-integrals:-Infinite-limits">Improper integrals: Infinite limits</a><a id="Improper-integrals:-Infinite-limits-1"></a><a class="docs-heading-anchor-permalink" href="#Improper-integrals:-Infinite-limits" title="Permalink"></a></h2><p><code>quadgk</code> supports &quot;improper&quot; integrals over infinite and semi-infinite intervals, simply by passing <code>±Inf</code> for the endpoints.</p><p>For example, <span>$\int_0^\infty e^{-x} dx = 1$</span> is computed by:</p><pre><code class="language-none">julia&gt; quadgk(x -&gt; exp(-x), 0, Inf)
(1.0, 4.507383379289404e-11)</code></pre><p>which give gives the correct answer (1) exactly in this case.  Note that the error estimate <code>≈ 4.5e-11</code> is pessimistic, as is often the case.</p><p>The <a href="https://en.wikipedia.org/wiki/Gaussian_integral">Gaussian integral</a> <span>$\int_{-\infty}^{+\infty} e^{-x^2} dx = \sqrt{\pi} = 1.772453850905516027298167483341\ldots$</span> is computed by:</p><pre><code class="language-none">julia&gt; quadgk(x -&gt; exp(-x^2), -Inf, Inf)
(1.7724538509055137, 6.4296367126505234e-9)</code></pre><p>which is the correct answer to nearly <a href="https://en.wikipedia.org/wiki/Machine_epsilon">machine precision</a>, despite the pessimistic error estimate <code>≈ 6.4e-9</code>.</p><p>Internally, <code>quadgk</code> handles infinite limits by the <a href="https://en.wikipedia.org/wiki/Integration_by_substitution">changes of variables</a></p><p class="math-container">\[\int_a^\infty f(x)dx = \int_0^1 f\left(a + \frac{t}{1-t}\right) \frac{1}{(1-t)^2} dt\]</p><p>and</p><p class="math-container">\[\int_{-\infty}^\infty f(x)dx = \int_{-1}^1 f\left(\frac{t}{1-t^2}\right) \frac{1+t^2}{(1-t^2)^2} dt\]</p><p>respectively.   Although the transformed integrands are singular at the endpoints <span>$t = 1$</span> and <span>$t = \pm 1$</span>, respectively, because the singularities are integrable and <code>quadgk</code> <em>never evaluates the integrand exactly at the endpoints</em>, it is able to perform the numerical integration successfully.</p><p>Important tip: This change-of-variables trick works best if your function decays with <span>$|x|$</span> over a lengthscale of order <span>$\sim 1$</span>. If your decay length is much larger or shorter than that, it will perform poorly.  For example, with <span>$f(x) = e^{-x/10^6}$</span> the decay is over a lengthscale <span>$\sim 10^6$</span> and <code>quadgk</code> requires many more evaluations (705) than for <span>$e^{-x}$</span> (135, as measured by <a href="../api/#QuadGK.quadgk_count"><code>quadgk_count</code></a>, described below):</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; exp(-x), 0, Inf)
(1.0, 4.507382674563286e-11, 135)

julia&gt; quadgk_count(x -&gt; exp(-x/1e6), 0, Inf)
(1.000000000001407e6, 0.0014578728207218505, 705)</code></pre><p>If your function decays over a lengthscale <span>$\sim L$</span>, it is a good idea to compute improper integrals using a change of variables <span>$\int_a^b f(x)dx = \int_{a/L}^{b/L} f(uL) L \, du$</span>, for example:</p><pre><code class="language-none">julia&gt; L = 1e6 # decay lengthscale
1.0e6

julia&gt; f(x) = exp(-x/L)
f (generic function with 1 method)

julia&gt; quadgk_count(u -&gt; f(u*L) * L, 0, Inf) # rescaled integration over u = x/L
(1.0e6, 4.507388807828416e-5, 135)</code></pre><h2 id="Counting-and-printing-integrand-evaluations"><a class="docs-heading-anchor" href="#Counting-and-printing-integrand-evaluations">Counting and printing integrand evaluations</a><a id="Counting-and-printing-integrand-evaluations-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-and-printing-integrand-evaluations" title="Permalink"></a></h2><p>Often, it is a good idea to count the number of times the integrand is evaluated, in order to have a sense of how efficiently <code>quadgk</code> is performing the integral; this is especially useful with badly behaved integrand (e.g. with singularities, discontinuities, sharp spikes, and/or rapid oscillations) to see whether some transformation of the problem might be helpful (see below).</p><p>This is easy enough by simply incrementing a global counter in your integrand function and printing progress as desired.    But it is such a common desire in pedagogy and debugging that we provide convenience functions <a href="../api/#QuadGK.quadgk_count"><code>quadgk_count</code></a> and <a href="../api/#QuadGK.quadgk_print"><code>quadgk_print</code></a> to automate this task.</p><p>For example, in our <span>$\int_0^\infty e^{-x} dx$</span> example from above, we could do:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; exp(-x), 0, Inf)
(1.0, 4.507383379289404e-11, 135)</code></pre><p>to return the number of function evaluations (<code>135</code>) along with the integral (<code>1.0</code>) and error estimate (<code>≈ 4.5e-11</code>).   A relatively large number of function evaluations are required, even though the function <span>$e^{-x}$</span> is very smooth, because the infinite endpoint implicitly introduces a singularity (via the change of variables discussed above).</p><p>We can also print the evaluation points, setting a lower requested relative accuracy of <code>rtol=1e-2</code> so that we don&#39;t get so much output, by:</p><pre><code class="language-none">julia&gt; quadgk_print(x -&gt; exp(-x), 0, Inf, rtol=1e-2)
f(1.0) = 0.36787944117144233
f(0.655923922306948) = 0.5189623601162878
f(1.52456705113438) = 0.21771529605384055
f(0.026110451522445993) = 0.9742274787577301
f(38.29883980138536) = 2.3282264081806294e-17
f(0.00429064542600238) = 0.9957185462423211
f(233.06516868994527) = 6.04064500678147e-102
f(0.14841469193194298) = 0.8620735458624529
f(6.737877409458626) = 0.0011851600983136456
f(0.07246402202084404) = 0.9300992091482783
f(13.799951646519888) = 1.015680581505947e-6
f(0.42263178703605514) = 0.6553198859704107
f(2.3661258586654506) = 0.09384358625528809
f(0.26096469051417465) = 0.7703081183184751
f(3.831936029467112) = 0.021667625834125973
(0.9999887201849575, 0.0009180738585039538, 15)</code></pre><p>to see that (for a relatively low requested relative accuracy of <code>rtol=1e-2</code>) it evaluates the integrand only 15 times at points from <span>$x \approx 0.00429$</span> to <span>$x \approx 233.1$</span>, and still managed to get about 5 significant digits correct.  (Note that <code>quadgk_print</code> again returns a 3-element tuple, like <code>quadgk_count</code>, where the third element is the number of integrand evaluations.)</p><h2 id="Integrands-with-singularities-and-discontinuities"><a class="docs-heading-anchor" href="#Integrands-with-singularities-and-discontinuities">Integrands with singularities and discontinuities</a><a id="Integrands-with-singularities-and-discontinuities-1"></a><a class="docs-heading-anchor-permalink" href="#Integrands-with-singularities-and-discontinuities" title="Permalink"></a></h2><p>The integral <span>$\int_0^1 x^{-1/2} dx = \left. 2 \sqrt{x} \right|_0^1 = 2$</span> is perfectly finite even though the integrand <span>$1/\sqrt{x}$</span> blows up at <span>$x=0$</span>.  This is an example of an <em>integrable singularity</em>, and <code>quadgk</code> can compute this integral:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; 1/sqrt(x), 0, 1)
(1.9999999845983916, 2.3762511924588765e-8, 1305)</code></pre><p>Notice the large number (<code>1305</code>) of integrand evaluations returned by <a href="../api/#QuadGK.quadgk_count"><code>quadgk_count</code></a>: this is an indication of how much more work it is to evaluate an integral with a singularity or any other form of non-smoothness. At its heart, the Gauss–Kronrod algorithm employed by <code>quadgk</code> works by interpolating the integrand with polynomials over segments of the domain, and polynomials are bad at representing <a href="https://en.wikipedia.org/wiki/Analytic_function">non-analytic functions</a> like <span>$1/\sqrt{x}$</span>.</p><p>The good news is that <code>quadgk</code> <strong>never evaluates functions exactly at the endpoints</strong>, so it is okay if your function blows up or errors at those points.   (However, you may have to relax your error tolerance because of the slow convergence, and floating-point limitations may prevent <code>quadgk</code> from reaching very low error tolerances for singular integrands.)   Of course, it is always better to remove the singularity by some analytical transformation if you can.  For example, if you need <span>$\int_0^a f(x) x^{-1/2} dx$</span>, you can do a change of variables <span>$x = y^2$</span> to obtain an equivalent integral <span>$\int_0^\sqrt{a} f(y^2) 2 dy$</span> that has no singularity and will therefore converge <em>much</em> more quickly.</p><p>If your integrand blows up (or has <em>any</em> singularity or discontinuity) in the <em>interior</em> of the integration domain, you should <em>add an extra &quot;endpoint&quot;</em> at that point to make sure we never evaluate it. (Also, <code>quadgk</code> can often converge more quickly if you tell it where your singularities are via the endpoints.)  For example, suppose we are integrating <span>$\int_0^2 |x-1|^{-1/2} dx = 4$</span>, which has an (integrable) singularity at <span>$x=1$</span>. If we don&#39;t tell <code>quadgk</code> about the singularity, it gets &quot;unlucky&quot; and evaluates the integrand exactly at <span>$x=1$</span>, which ends up throwing an error:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; 1/sqrt(abs(x-1)), 0, 2)
ERROR: DomainError with 1.0:
integrand produced NaN in the interval (0, 2)
...</code></pre><p>Instead, if we <em>tell</em> it to subdivide the integral at <span>$x=1$</span>, we get the correct answer(<code>≈ 4</code>):</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; 1/sqrt(abs(x-1)), 0, 1, 2)
(3.9999999643041515, 5.8392038954259235e-8, 2580)</code></pre><p>In general, the syntax <code>quadgk(f, a, b, c, ...)</code> denotes the integral <span>$\int_a^b f(x)dx + \int_b^c f(x)dx  + \cdots$</span>, and <code>quadgk</code> never evaluates the integrand <span>$f(x)$</span> exactly at the endpoints <span>$a, b, c, \ldots$</span>.</p><p>As another example, consider an integral <span>$\int_0^3 H(x-1) = 2$</span> of the discontinuous <a href="https://en.wikipedia.org/wiki/Heaviside_step_function">Heaviside step function</a> <span>$H(x)$</span>, which <span>$=1$</span> when <span>$x &gt; 0$</span> and <span>$=0$</span> when <span>$x \le 0$</span>:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; x &gt; 1, 0, 3)
(2.0000000043200235, 1.7916158219741817e-8, 705)</code></pre><p>Even though <span>$H(x-1)$</span> is nearly constant, <code>quadgk</code> struggles to integrate it (<code>705</code> function evaluations to get about 8 digits), thanks to the discontinuity at <span>$x=1$</span>. (Note that <code>true</code> and <code>false</code> in Julia are equal to numeric <code>0</code> and <code>1</code>, which is why we could implement <span>$H(x-1)$</span> as simply <code>x &gt; 1</code>.) On the other hand, if we <em>tell it</em> the location of the discontinuity:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; x &gt; 1, 0, 1, 3)
(2.0, 0.0, 30)</code></pre><p>then it gives the <em>exact</em> answer in only 30 evaluations.  The reason it takes 30 evaluations is because <code>quadgk</code> defaults to 7th-order Gauss–Kronrod integration rule, which uses 15 points to interpolate with a high-degree polynomial.  Once we subdivide the integral, we could actually get away with a lower-order rule by setting the <code>order</code> parameter, e.g.:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; x &gt; 1, 0, 1, 3, order=1)
(2.0, 0.0, 6)</code></pre><h2 id="Complex-and-vector-valued-integrands"><a class="docs-heading-anchor" href="#Complex-and-vector-valued-integrands">Complex and vector-valued integrands</a><a id="Complex-and-vector-valued-integrands-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-and-vector-valued-integrands" title="Permalink"></a></h2><p>The integrand <code>f(x)</code> can return not just real numbers, but also complex numbers, vectors, matrices, or any Julia type supporting <code>±</code>, multiplication by scalars, and <code>norm</code> (i.e. implementing any <a href="https://en.wikipedia.org/wiki/Banach_space">Banach space</a>).</p><p>For example, we can integrate <span>$1/\sqrt{x}$</span> from <span>$x=-1$</span> to <span>$x=1$</span>, where we <a href="https://docs.julialang.org/en/v1/manual/faq/#faq-domain-errors">tell the <code>sqrt</code> function to return a complex result</a> for negative arguments:</p><pre><code class="language-none">julia&gt; quadgk(x -&gt; 1/sqrt(complex(x)), -1, 0, 1)
(1.9999999891094182 - 1.9999999845983916im, 4.056765398346683e-8)</code></pre><p>which correctly gives <span>$\approx 2 - 2i$</span>.  Note that we explicitly put an endpoint at <span>$x=0$</span> to tell <code>quadgk</code> about the singularity at that point, as described above.</p><p>Or let&#39;s integrate the vector-valued function <span>$f(x) = [1, x, x^2, x^3]$</span> for <span>$x \in (0,1)$</span>:</p><pre><code class="language-none">julia&gt; quadgk(x -&gt; [1,x,x^2,x^3], 0, 1)
([1.0, 0.5, 0.3333333333333333, 0.25], 6.206335383118183e-17)</code></pre><p>which correctly returns <span>$\approx [1, \frac{1}{2}, \frac{1}{3}, \frac{1}{4}]$</span>.  Note that the error estimate in this case is an approximate bound on the <a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">norm</a> of the error, as computed by the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> function in Julia.  It defaults to the Euclidean (L2) norm, but you can change this with the <code>norm</code> argument:</p><pre><code class="language-none">julia&gt; quadgk(x -&gt; [1,x,x^2,x^3], 0, 1, norm=v-&gt;maximum(abs, v))
([1.0, 0.5, 0.3333333333333333, 0.25], 5.551115123125783e-17)</code></pre><p>e.g. to use the <a href="https://en.wikipedia.org/wiki/Chebyshev_distance">maximum norm</a> or some other norm (e.g. a weighted norm if the different components have different units or have unequal error tolerances).</p><p>For integrands whose values are <em>small</em> arrays whose length is known at compile time, it is <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Consider-StaticArrays.jl-for-small-fixed-size-vector/matrix-operations">usually most efficient</a> to modify your integrand to return an <code>SVector</code> from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl package</a>.  For the example above:</p><pre><code class="language-none">julia&gt; using StaticArrays

julia&gt; integral, error = quadgk(x -&gt; @SVector[1,x,x^2,x^3], 0, 1)
([1.0, 0.5, 0.3333333333333333, 0.25], 6.206335383118183e-17)

julia&gt; typeof(integral)
SVector{4, Float64} (alias for SArray{Tuple{4}, Float64, 1, 4})</code></pre><p>Note that the return value also gives the <code>integral</code> as an <code>SVector</code> (a <a href="https://en.wikipedia.org/wiki/Static_program_analysis">statically</a> sized array).</p><p>The QuadGK package did not need any code specific to StaticArrays, and was written long before that package even existed.  The fact that unrelated packages like this can be <a href="https://en.wikipedia.org/wiki/Composability">composed</a> is part of the <a href="https://www.youtube.com/watch?v=kc9HwsxE1OY">beauty of multiple dispatch</a> and <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> for <a href="https://en.wikipedia.org/wiki/Generic_programming">generic programming</a>.</p><h2 id="Batched-integrand-evaluation"><a class="docs-heading-anchor" href="#Batched-integrand-evaluation">Batched integrand evaluation</a><a id="Batched-integrand-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Batched-integrand-evaluation" title="Permalink"></a></h2><p>User-side parallelization of integrand evaluations is also possible by providing an in-place function of the form <code>f!(y,x) = y .= f.(x)</code>, which evaluates the integrand at multiple points simultaneously. To use this API, <code>quadgk</code> dispatches on a <a href="../api/#QuadGK.BatchIntegrand"><code>BatchIntegrand</code></a> type containing <code>f!</code> and buffers for <code>y</code> and <code>x</code>. These buffers may be pre-allocated and reused for multiple <code>BatchIntegrand</code>s with the same domain and range types.</p><p>For example, we can perform multi-threaded integration of a highly oscillatory function that needs to be refined globally:</p><pre><code class="language-none">julia&gt; f(x) = sin(100x)
f (generic function with 1 method)

julia&gt; function f!(y, x)
           n = Threads.nthreads()
           Threads.@threads for i in 1:n
                y[i:n:end] .= f.(@view(x[i:n:end]))
           end
       end
f! (generic function with 1 method)

julia&gt; quadgk(BatchIntegrand{Float64}(f!), 0, 1)
(0.0013768112771231598, 8.493080824940099e-12)</code></pre><p>Batching also changes how the adaptive refinement is done, which typically leads to slightly different results and sometimes more integrand evaluations. You can limit the maximum batch size by setting the <code>max_batch</code> parameter of the <a href="../api/#QuadGK.BatchIntegrand"><code>BatchIntegrand</code></a>, which can be useful in order to set an upper bound on the size of the buffers allocated by <code>quadgk</code>.</p><h2 id="Arbitrary-precision-integrals"><a class="docs-heading-anchor" href="#Arbitrary-precision-integrals">Arbitrary-precision integrals</a><a id="Arbitrary-precision-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrary-precision-integrals" title="Permalink"></a></h2><p><code>quadgk</code> also supports <a href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">arbitrary-precision arithmetic</a> using Julia&#39;s <a href="https://docs.julialang.org/en/v1/base/numbers/#BigFloats-and-BigInts"><code>BigFloat</code> type</a> to compute integrals to arbitrary accuracy (albeit at increased computational cost).</p><p>For example, we can compute the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> <span>$\frac{\sqrt{\pi}}{2} \text{erf}(1) = \int_0^1 e^{-x^2} dx$</span> to 50 digits by:</p><pre><code class="language-none">julia&gt; setprecision(60, base=10) # use 60-digit arithmetic
60

julia&gt; quadgk_count(x -&gt; exp(-x^2), big&quot;0.0&quot;, big&quot;1.0&quot;, rtol=1e-50)
(0.74682413281242702539946743613185300535449968681260632902766195, 6.8956257635323481758755998484087241330474674891762053644928492e-51, 15345)</code></pre><p>The correct answer is <code>≈ 0.746824132812427025399467436131853005354499686812606329027654498958605…</code>, and we are matching that to nearly the full precision (≈ 60 digits).  (As usual, the error estimate of <code>quadgk</code> is very conservative for smooth functions.)</p><p>Unfortunately, it took 15345 function evaluations to obtain such an accurate answer.  Since this a smooth integrand, for high-accuracy calculations it is often advisable to increase the &quot;order&quot; of the quadrature algorithm (which is related to the degree of polynomials used for interpolation).  The default is <code>order=7</code>, but let&#39;s try tripling it to <code>order=21</code>:</p><pre><code class="language-none">julia&gt; quadgk_count(x -&gt; exp(-x^2), big&quot;0.0&quot;, big&quot;1.0&quot;, rtol=1e-50, order=21)
(0.74682413281242702539946743613185300535449968681260632902765324, 2.1873898701681913100611385149037136705674736373054902472850425e-58, 129)</code></pre><p>It got the same accuracy (≈ 60 digits) with only 129 integrand evaluations!</p><h2 id="Contour-integration"><a class="docs-heading-anchor" href="#Contour-integration">Contour integration</a><a id="Contour-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Contour-integration" title="Permalink"></a></h2><p>You can specify a sequence of points in the complex plane to perform a <a href="https://en.wikipedia.org/wiki/Contour_integration">contour integrals</a> with <code>quadgk</code> along a piecewise-linear contour.</p><p>For example, consider the function <span>$f(z) = \cos(z)/z$</span>.  By the <a href="https://en.wikipedia.org/wiki/Residue_theorem">residue theorem</a> of complex analysis, if we integrate counter-clockwise in a &quot;loop&quot; around the <a href="https://en.wikipedia.org/wiki/Zeros_and_poles">pole</a> at <span>$z=0$</span>, we should get exactly <span>$2\pi i \cos(0) = 2\pi i$</span>.</p><p>One way to do this integral is to <a href="https://en.wikipedia.org/wiki/Parametric_equation">parameterize a contour</a>, say a circle <span>$|z|=1$</span> parameterized by <span>$z= e^{i\phi}$</span> (<code>= cis(ϕ)</code> in Julia), which gives <span>$dz = i z\, d\phi$</span>, to obtain an ordinary integral <span>$\int_0^{2\pi} \frac{\cos(e^{i\phi})}{e^{i\phi}} ie^{i\phi} d\phi$</span> over the <em>real</em> parameter <span>$\phi \in (0,2\pi)$</span>:</p><pre><code class="language-none">julia&gt; quadgk(ϕ -&gt; cos(cis(ϕ)) * im, 0, 2π)
(0.0 + 6.283185307179586im, 1.8649646913725044e-8)</code></pre><p>which indeed gives us <span>$\approx 2\pi i$</span> (to machine precision).</p><p>As an alternative, however, you can directly supply a sequence of <em>complex &quot;endpoints&quot;</em> to <code>quadgk</code> and it will perform the contour integral along a sequence of line segments connecting these points.  For example, instead of integrating around a circular contour, we can integrate around the diamond (rotated square) connecting the corners <span>$\pm 1$</span> and <span>$\pm i$</span>:</p><pre><code class="language-none">julia&gt; quadgk(z -&gt; cos(z)/z, 1, im, -1, -im, 1)
(0.0 + 6.283185307179587im, 5.369976662961913e-9)</code></pre><p>which again gives <span>$\approx 2\pi i$</span> (to machine precision).  Note that it is critically important to have a <em>closed</em> contour (a loop): the final endpoint must be the same as the starting point (<span>$z=1$</span>).</p><h2 id="Cauchy-principal-values"><a class="docs-heading-anchor" href="#Cauchy-principal-values">Cauchy principal values</a><a id="Cauchy-principal-values-1"></a><a class="docs-heading-anchor-permalink" href="#Cauchy-principal-values" title="Permalink"></a></h2><p>Integrands <span>$f(x) = g(x)/x$</span> that diverge <span>$\sim 1/x$</span> cannot be integrated through <span>$x=0$</span> in the usual way (the singularity is not integrable). However, if you integrate <em>around</em> <span>$x=0$</span>, for both signs of <span>$x$</span>, then you can define a kind of integral that is the &quot;difference&quot; of the divergence on the two sides.  This definition is called a <a href="https://en.wikipedia.org/wiki/Cauchy_principal_value">Cauchy principal value</a>, and is usually presented as a limit:</p><p class="math-container">\[\text{p.v.}\int_a^b \frac{g(x)}{x} dx =
\lim_{\varepsilon\to 0^+} \left[
    \int_a^{-\varepsilon} \frac{g(x)}{x} dx + \int_{+\varepsilon}^b \frac{g(x)}{x} dx
\right] \, .\]</p><p>That is, you subtract a &quot;ball&quot; of radius <span>$\varepsilon$</span> from the integration domain <span>$a &lt; 0 &lt; b$</span> to eliminate the singularity at <span>$x=0$</span>, and take the limit of the resulting integral as the <span>$\varepsilon$</span> goes to zero.</p><p>In principle, you might imagine taking this limit numerically by extrapolation of numerical integrals for a sequence of <span>$\varepsilon &gt; 0$</span> values, perhaps using Richardson extrapolation via the <a href="https://github.com/JuliaMath/Richardson.jl">Richardson.jl package</a>.  However, it is mathematically equivalent and <em>much</em> more efficient to use a simple singularity-subtraction procedure:</p><p class="math-container">\[\frac{g(x)}{x}  =
\frac{g(x)-g(0)}{x} + \frac{g(0)}{x}\]</p><p>where the first term is <em>not singular</em> if <span>$g(x)$</span> is differentiable at <span>$x=0$</span>, and the latter term can be integrated analytically, giving:</p><p class="math-container">\[\text{p.v.}\int_a^b \frac{g(x)}{x} dx = \int_a^b \frac{g(x)-g(0)}{x} dx +
g(0) \log|b/a|\]</p><p>Since the remaining integral has no singularity, we can do it numerically directly.  There are two tricks to help us a bit further:</p><ul><li>As in <a href="#Integrands-with-singularities-and-discontinuities">Integrands with singularities and discontinuities</a> above, we&#39;ll want to put an extra endpoint at <span>$x=0$</span> to make sure <code>quadgk</code> doesn&#39;t evaluate the integrand exactly at that point (which would give <code>NaN</code> from <span>$0/0$</span>).</li><li>We should be careful with the integration tolerances, to make sure that any relative tolerance <code>rtol</code> is applied with respect to the whole principal part and not just to the <span>$g(x)-g(0)$</span> integral.  An easy way to do this is to add <span>$g(0) \frac{\log|b/a|}{b-a}$</span> to the <em>integrand</em>, so that we no longer compute the two pieces separately.</li></ul><p>Putting it all together, here is a function <code>cauchy_quadgk(g, a, b)</code> that computes our Cauchy principal part <span>$\text{p.v.}\int_a^b g(x)/x$</span>:</p><pre><code class="language-none">function cauchy_quadgk(g, a, b; kws...)
    a &lt; 0 &lt; b || throw(ArgumentError(&quot;domain must include 0&quot;))
    g₀ = g(0)
    g₀int = b == -a ? zero(g₀) : g₀ * log(abs(b/a)) / (b - a)
    return quadgk_count(x -&gt; (g(x)-g₀)/x + g₀int, a, 0, b; kws...)
end</code></pre><p>For example, <a href="https://www.wolframalpha.com/input?i=Integrate%5BCos%5Bx%5E2-1%5D%2Fx%2C+%7Bx%2C+-1%2C+2%7D%2C+PrincipalValue+-%3E+True%5D">Mathematica tells us</a> that</p><p class="math-container">\[\text{p.v.} \int_{-1}^2 \frac{\cos(x^2-1)}{x} dx \approx 0.212451309942989788929352736695\ldots ,\]</p><p>and we can reproduce this with <code>cauchy_quadgk</code>:</p><pre><code class="language-none">julia&gt; cauchy_quadgk(x -&gt; cos(x^2-1), -1, 2)
(0.21245130994298977, 1.8366794196644776e-11, 60)</code></pre><p>which is correct to about 16 digits.</p><p>This approach and other approaches to computing Cauchy principal values are discussed in <a href="https://doi.org/10.1016/j.cam.2015.08.021">Keller and Wróbel (2016)</a>. This kind of &quot;singularity subtraction&quot; is a powerful approach to efficient computation of integrals with singularities or near singularities. A huge variety of related techniques have been developed for <a href="https://en.wikipedia.org/wiki/Boundary_element_method">boundary element methods</a>, where a vast number of singular integrals must be computed and efficiency is at a premium.  See, for example, <a href="http://doi.org/10.1109/TAP.2014.2367492">Reid <em>et al.</em> (2014)</a> and references therein.</p><h2 id="Nearly-singular-integrands"><a class="docs-heading-anchor" href="#Nearly-singular-integrands">Nearly singular integrands</a><a id="Nearly-singular-integrands-1"></a><a class="docs-heading-anchor-permalink" href="#Nearly-singular-integrands" title="Permalink"></a></h2><p>Even if the integrand is only <em>nearly</em> singular, so that there is a sharp but <em>finite</em> peak within the integration domain, it can greatly increase the efficiency of numerical integration if you can separate the sharp peak analytically.</p><p>For example, suppose that you are integrating:</p><p class="math-container">\[I = \int_a^b \frac{g(x)}{x - i\alpha} dx\]</p><p>for a small <span>$0 &lt; \alpha \ll 1$</span>.  For <span>$\alpha \to 0^+$</span>, it approaches <span>$i\pi g(0)$</span> plus a Cauchy principal part (the latter being zero if <span>$a = -b$</span> and <span>$g(x)=g(-x)$</span>), but for small <span>$\alpha &gt; 0$</span> you have to numerically integrate (for a general function <span>$g(x)$</span>) a function with a sharp spike at <span>$x=0$</span>, which will require a large number of quadrature points.  But you can subtract out the singularity analytically:</p><p class="math-container">\[I = \int_a^b \left[ \frac{g(x)-g(0)}{x - i\alpha} + \frac{g(0)}{x - i\alpha} \right] dx \\
= \int_a^b \frac{g(x)-g(0)}{x - i\alpha}dx + \underbrace{g(0) \left[\frac{1}{2}\log(x^2 + \alpha^2) + i\tan^{-1}(x/\alpha) \right]_a^b}_{I_0}\]</p><p>and then you only need to numerically integrate <span>$I - I_0$</span>, which has the spike subtracted.</p><p>As for <a href="#Cauchy-principal-values">Cauchy principal values</a> above, we want to include a <span>$I_0 / (b-a)$</span> term directly in the integrand so that the error tolerances are computed correctly, and include <span>$x=0$</span> as an explicit endpoint to let <code>quadgk</code> know that the integral is badly behaved there.</p><p>In code:</p><pre><code class="language-none">using QuadGK

function int_slow(g, α, a, b; kws...)
    if a &lt; 0 &lt; b
        # put an explicit endpoint at x=0 since we know it is badly behaved there
        return quadgk_count(x -&gt; g(x) / (x - im*α), a, 0, b; kws...)
    else
        return quadgk_count(x -&gt; g(x) / (x - im*α), a, b; kws...)
    end
end

function int_fast(g, α, a, b; kws...)
    g₀ = g(0)
    denom_int(x) = log(x^2 + α^2)/2 + im * atan(x/α)
    I₀ = g₀ * (denom_int(b) - denom_int(a))
    if a &lt; 0 &lt; b
        # put an explicit endpoint at x=0 since we know it is badly behaved there
        (I,E,c) = quadgk_count(x -&gt; I₀/(b-a) + (g(x) - g₀) / (x - im*α), a, 0, b; kws...)
    else
        (I,E,c) = quadgk_count(x -&gt; I₀/(b-a) + (g(x) - g₀) / (x - im*α), a, b; kws...)
    end
    return (I,E,c+1) # add 1 for g(0) evaluation
end</code></pre><p>This gives:</p><pre><code class="language-none">julia&gt; int_slow(cos, 1e-6, -1, 1)
(1.1102230246251565e-16 + 3.1415896808206125im, 1.4895091715264936e-9, 1230)

julia&gt; int_fast(cos, 1e-6, -1, 1)
(3.3306690738754696e-16 + 3.1415896808190418im, 1.8459683038047577e-12, 31)</code></pre><p>which agree to about 13 digits, but the slow brute-force method requires 1230 function evaluations while the fast singularity-subtracted method requires only 31 function evaluations.</p><p>As an added bonus, <code>int_fast</code> works even for <code>α = 0</code>, where it gives you <span>$i\pi g(0)$</span> (for <span>$0 \in (a,b)$</span>) plus the Cauchy principal part as above.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../gauss-kronrod/">Quadrature rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 January 2024 23:37">Monday 22 January 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
