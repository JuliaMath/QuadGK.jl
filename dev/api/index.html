<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · QuadGK.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuadGK.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quadgk-examples/">Examples</a></li><li><a class="tocitem" href="../gauss-kronrod/">Quadrature rules</a></li><li><a class="tocitem" href="../weighted-gauss/">Weighted quadrature</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#quadgk"><span><code>quadgk</code></span></a></li><li><a class="tocitem" href="#Gauss-and-Gauss–Kronrod-rules"><span>Gauss and Gauss–Kronrod rules</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/QuadGK.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><h2 id="quadgk"><a class="docs-heading-anchor" href="#quadgk"><code>quadgk</code></a><a id="quadgk-1"></a><a class="docs-heading-anchor-permalink" href="#quadgk" title="Permalink"></a></h2><p>The most commonly used function from the QuadGK package is the <code>quadgk</code> function, used to compute numerical integrals (by h-adaptive Gauss–Kronrod quadrature):</p><article class="docstring"><header><a class="docstring-binding" id="QuadGK.quadgk" href="#QuadGK.quadgk"><code>QuadGK.quadgk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quadgk(f, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm, segbuf=nothing)</code></pre><p>Numerically integrate the function <code>f(x)</code> from <code>a</code> to <code>b</code>, and optionally over additional intervals <code>b</code> to <code>c</code> and so on. Keyword options include a relative error tolerance <code>rtol</code> (if <code>atol==0</code>, defaults to <code>sqrt(eps)</code> in the precision of the endpoints), an absolute error tolerance <code>atol</code> (defaults to 0), a maximum number of function evaluations <code>maxevals</code> (defaults to <code>10^7</code>), and the <code>order</code> of the integration rule (defaults to 7).</p><p>Returns a pair <code>(I,E)</code> of the estimated integral <code>I</code> and an estimated upper bound on the absolute error <code>E</code>. If <code>maxevals</code> is not exceeded then <code>E &lt;= max(atol, rtol*norm(I))</code> will hold. (Note that it is useful to specify a positive <code>atol</code> in cases where <code>norm(I)</code> may be zero.)</p><p>The endpoints <code>a</code> et cetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are <code>BigFloat</code>, then the integration will be performed in <code>BigFloat</code> precision as well.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is advisable to increase the integration <code>order</code> in rough proportion to the precision, for smooth integrands.</p></div></div><p>More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).</p><p>The integrand <code>f(x)</code> can return any numeric scalar, vector, or matrix type, or in fact any type supporting <code>+</code>, <code>-</code>, multiplication by real values, and a <code>norm</code> (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a <code>norm</code>-like function as the <code>norm</code> keyword argument (which defaults to <code>norm</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).</p></div></div><p>The algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (<code>2*order+1</code> points) and the error is estimated using an embedded Gauss rule (<code>order</code> points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.</p><p>These quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if <code>f</code> has a discontinuity at <code>x=0.7</code> and you want to integrate from 0 to 1, you should use <code>quadgk(f, 0,0.7,1)</code> to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a <code>log(x)</code> or <code>1/sqrt(x)</code> singularity).</p><p>For real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)</p><p>In normal usage, <code>quadgk(...)</code> will allocate a buffer for segments. You can instead pass a preallocated buffer allocated using <code>alloc_segbuf(...)</code> as the <code>segbuf</code> argument. This buffer can be used across multiple calls to avoid repeated allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/adapt.jl#L153-L212">source</a></section></article><p>The <code>quadgk</code> function also has variants <code>quadgk_count</code> (which also returns a count of the integrand evaluations), <code>quadgk_print</code> (which also prints each integrand evaluation), <code>quadgk!</code> (which implements an in-place API for array-valued functions), as well as an <code>alloc_segbuf</code> function to pre-allocate internal buffers used by <code>quadgk</code>:</p><article class="docstring"><header><a class="docstring-binding" id="QuadGK.quadgk_count" href="#QuadGK.quadgk_count"><code>QuadGK.quadgk_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quadgk_count(f, args...; kws...)</code></pre><p>Identical to <a href="#QuadGK.quadgk"><code>quadgk</code></a> but returns a triple <code>(I, E, count)</code> of the estimated integral <code>I</code>, the estimated error bound <code>E</code>, and a <code>count</code> of the number of times the integrand <code>f</code> was evaluated.</p><p>The count of integrand evaluations is a useful performance metric: a large number typically indicates a badly behaved integrand (with singularities, discontinuities, sharp peaks, and/or rapid oscillations), in which case it may be possible to mathematically transform the problem in some way to improve the convergence rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/adapt.jl#L266-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuadGK.quadgk_print" href="#QuadGK.quadgk_print"><code>QuadGK.quadgk_print</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quadgk_print([io], f, args...; kws...)</code></pre><p>Identical to <a href="#QuadGK.quadgk"><code>quadgk</code></a>, but <strong>prints</strong> each integrand evaluation to the stream <code>io</code> (defaults to <code>stdout</code>) in the form:</p><pre><code class="language-none">f(x1) = y1
f(x2) = y2
...</code></pre><p>which is useful for pedagogy and debugging.</p><p>Also, like <a href="#QuadGK.quadgk_count"><code>quadgk_count</code></a>, it returns a triple <code>(I, E, count)</code> of the estimated integral <code>I</code>, the estimated error bound <code>E</code>, and a <code>count</code> of the number of times the integrand <code>f</code> was evaluated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/adapt.jl#L288-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuadGK.quadgk!" href="#QuadGK.quadgk!"><code>QuadGK.quadgk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quadgk!(f!, result, a,b,c...; rtol=sqrt(eps), atol=0, maxevals=10^7, order=7, norm=norm)</code></pre><p>Like <code>quadgk</code>, but make use of in-place operations for array-valued integrands (or other mutable types supporting in-place operations).  In particular, there are two differences from <code>quadgk</code>:</p><ol><li><p>The function <code>f!</code> should be of the form <code>f!(y, x) = y .= f(x)</code>.  That is, it writes the return value of the integand <code>f(x)</code> in-place into its first argument <code>y</code>.   (The return value of <code>f!</code> is ignored.)</p></li><li><p>Like <code>quadgk</code>, the return value is a tuple <code>(I,E)</code> of the estimated integral <code>I</code> and the estimated error <code>E</code>.   However, in <code>quadgk!</code> the estimated integral is written in-place into the <code>result</code> argument, so that <code>I === result</code>.</p></li></ol><p>Otherwise, the behavior is identical to <code>quadgk</code>.</p><p>For integrands whose values are <em>small</em> arrays whose length is known at compile-time, it is usually more efficient to use <code>quadgk</code> and modify your integrand to return an <code>SVector</code> from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl package</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/adapt.jl#L237-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuadGK.alloc_segbuf" href="#QuadGK.alloc_segbuf"><code>QuadGK.alloc_segbuf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function alloc_segbuf(domain_type=Float64, range_type=Float64, error_type=Float64; size=1)</code></pre><p>This helper will allocate a segment buffer for segments to a <code>quadgk(...)</code> call with the given <code>domain_type</code>, which is the same as the type of the integration limits, <code>range_type</code> i.e. the range of the function being integrated and <code>error_type</code>, the type returned by the <code>norm</code> given to <code>quadgk(...)</code> and starting with the given <code>size</code>. The buffer can then be reused across multiple compatible calls to <code>quadgk(...)</code> to avoid repeated allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/adapt.jl#L223-L232">source</a></section></article><h2 id="Gauss-and-Gauss–Kronrod-rules"><a class="docs-heading-anchor" href="#Gauss-and-Gauss–Kronrod-rules">Gauss and Gauss–Kronrod rules</a><a id="Gauss-and-Gauss–Kronrod-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Gauss-and-Gauss–Kronrod-rules" title="Permalink"></a></h2><p>For more specialized applications, you may wish to construct your own Gauss or Gauss–Kronrod quadrature rules, as described in <a href="../gauss-kronrod/#Gauss-and-Gauss–Kronrod-quadrature-rules">Gauss and Gauss–Kronrod quadrature rules</a>.   To compute rules for <span>$\int_{-1}^{+1} f(x) dx$</span> and <span>$\int_a^b f(x) dx$</span> (unweighted integrals), use:</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>QuadGK.gauss(::Type, ::Integer)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>QuadGK.kronrod(::Type, ::Integer)</code>. Check Documenter&#39;s build log for details.</p></div></div><p>More generally, to compute rules for <span>$\int_a^b w(x) f(x) dx$</span> (weighted integrals, as described in <a href="../weighted-gauss/#Gaussian-quadrature-and-arbitrary-weight-functions">Gaussian quadrature and arbitrary weight functions</a>), use the following methods if you know the <a href="https://en.wikipedia.org/wiki/Jacobi_operator">Jacobi matrix</a> for the orthogonal polynomials associated with your weight function:</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>QuadGK.gauss(::AbstractMatrix, ::Real)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>QuadGK.kronrod(::AbstractMatrix, ::Integer, ::Real)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="QuadGK.HollowSymTridiagonal" href="#QuadGK.HollowSymTridiagonal"><code>QuadGK.HollowSymTridiagonal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuadGK.HollowSymTridiagonal(ev::AbstractVector)</code></pre><p>Construct a &quot;hollow&quot; symmetric tridiagonal matrix, whose diagonal entries are zero and whose first sub/super-diagonal is <code>ev</code>.</p><p>The <code>HollowSymTridiagonal</code> type can be passed to <a href="#QuadGK.gauss-Tuple{Any, Integer, Real, Real}"><code>gauss</code></a> or <a href="#QuadGK.kronrod-Tuple{Any, Integer, Real, Real}"><code>kronrod</code></a> for Jacobi matrices to dispatch to specialized methods that exploit the special &quot;hollow&quot; structure arising for symmetric weight functions, in order to generate symmetric quadrature rules more efficiently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/gausskronrod.jl#L32-L41">source</a></section></article><p>Most generally, if you know only the weight function <span>$w(x)$</span> and the interval <span>$(a,b)$</span>, you can construct Gauss and Gauss–Kronrod rules completely numerically using:</p><article class="docstring"><header><a class="docstring-binding" id="QuadGK.gauss-Tuple{Any, Integer, Real, Real}" href="#QuadGK.gauss-Tuple{Any, Integer, Real, Real}"><code>QuadGK.gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gauss(W, N, a, b; rtol=sqrt(eps), quad=quadgk)</code></pre><p>Return a pair <code>(x, w)</code> of <code>N</code> quadrature points <code>x[i]</code> and weights <code>w[i]</code> to integrate functions on the interval <code>(a, b)</code> multiplied by the weight function <code>W(x)</code>.  That is, <code>sum(w .* f.(x))</code> approximates the integral <code>∫ W(x)f(x)dx</code> from <code>a</code> to <code>b</code>.</p><p>This function performs <code>2N</code> numerical integrals of polynomials against <code>W(x)</code> using the integration function <code>quad</code> (defaults to <code>quadgk</code>) with relative tolerance <code>rtol</code> (which defaults to half of the precision <code>eps</code> of the endpoints). This is followed by an O(N²) calculations. So, using a large order <code>N</code> is expensive.</p><p>If <code>W</code> has lots of singularities that make it hard to integrate numerically, you may need to decrease <code>rtol</code>.   You can also pass in a specialized quadrature routine via the <code>quad</code> keyword argument, which should accept arguments <code>quad(f,a,b,rtol=_,atol=_)</code> similar to <code>quadgk</code>.  (This is useful if your weight function has discontinuities, in which case you might want to break up the integration interval at the discontinuities.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/weightedgauss.jl#L41-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuadGK.kronrod-Tuple{Any, Integer, Real, Real}" href="#QuadGK.kronrod-Tuple{Any, Integer, Real, Real}"><code>QuadGK.kronrod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kronrod(W, N, a, b; rtol=sqrt(eps), quad=quadgk)</code></pre><p>Return a tuple <code>(x, w, wg)</code> of <code>N</code> quadrature points <code>x[i]</code> and weights <code>w[i]</code> to integrate functions on the interval <code>(a, b)</code> multiplied by the weight function <code>W(x)</code>, along with the weights <code>wg</code> of an embedded Gauss rule corresponding to <code>x[2:2:end]</code>, similar to the <code>gauss(W, N, a, b)</code> function and analogous to <code>kronrod(N)</code> (which only returns the <code>x ≤ 0</code> points for a constant weight function).</p><p>That is, <code>I = sum(w .* f.(x))</code> approximates the integral <code>∫ W(x)f(x)dx</code> from <code>a</code> to <code>b</code>.  And an error estimate is <code>abs(I - Ig)</code>, where <code>Ig</code> is the result <code>Ig = sum(wg .* f.(x[2:2:end]))</code> of the embedded Gauss rule.</p><p>This function performs <code>≈ 3N+3</code> numerical integrals of polynomials against <code>W(x)</code> using the integration function <code>quad</code> (defaults to <code>quadgk</code>) with relative tolerance <code>rtol</code> (which defaults to half of the precision <code>eps</code> of the endpoints). This is followed by an O(N²) calculations. So, using a large order <code>N</code> is expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/QuadGK.jl/blob/a072fda95c207919adae7ea46a8408300264d8dc/src/weightedgauss.jl#L70-L87">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../weighted-gauss/">« Weighted quadrature</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 July 2023 14:48">Tuesday 25 July 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
